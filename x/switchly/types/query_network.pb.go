// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/query_network.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryNetworkRequest struct {
	Height string `protobuf:"bytes,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *QueryNetworkRequest) Reset()         { *m = QueryNetworkRequest{} }
func (m *QueryNetworkRequest) String() string { return proto.CompactTextString(m) }
func (*QueryNetworkRequest) ProtoMessage()    {}
func (*QueryNetworkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9f8f442a8cc0ad, []int{0}
}
func (m *QueryNetworkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNetworkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNetworkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNetworkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNetworkRequest.Merge(m, src)
}
func (m *QueryNetworkRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryNetworkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNetworkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNetworkRequest proto.InternalMessageInfo

func (m *QueryNetworkRequest) GetHeight() string {
	if m != nil {
		return m.Height
	}
	return ""
}

type QueryNetworkResponse struct {
	// total amount of SWITCH awarded to node operators
	BondRewardSwitch string `protobuf:"bytes,1,opt,name=bond_reward_switch,json=bondRewardSwitch,proto3" json:"bond_reward_switch"`
	// total bonded SWITCH
	TotalBondUnits string `protobuf:"bytes,2,opt,name=total_bond_units,json=totalBondUnits,proto3" json:"total_bond_units"`
	// SWITCH in Available pools (equal in value to the Assets in those pools)
	AvailablePoolsSwitch string `protobuf:"bytes,15,opt,name=available_pools_switch,json=availablePoolsSwitch,proto3" json:"available_pools_switch"`
	// SWITCH value of Layer 1 Assets in vaults
	VaultsLiquiditySwitch string `protobuf:"bytes,16,opt,name=vaults_liquidity_switch,json=vaultsLiquiditySwitch,proto3" json:"vaults_liquidity_switch"`
	// effective security bond used to determine maximum pooled SWITCH
	EffectiveSecurityBond string `protobuf:"bytes,3,opt,name=effective_security_bond,json=effectiveSecurityBond,proto3" json:"effective_security_bond"`
	// total reserve SWITCH
	TotalReserve string `protobuf:"bytes,4,opt,name=total_reserve,json=totalReserve,proto3" json:"total_reserve"`
	// Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults
	VaultsMigrating bool `protobuf:"varint,5,opt,name=vaults_migrating,json=vaultsMigrating,proto3" json:"vaults_migrating"`
	// Sum of the gas the network has spent to send outbounds
	GasSpentSwitch string `protobuf:"bytes,6,opt,name=gas_spent_switch,json=gasSpentSwitch,proto3" json:"gas_spent_switch"`
	// Sum of the gas withheld from users to cover outbound gas
	GasWithheldSwitch string `protobuf:"bytes,7,opt,name=gas_withheld_switch,json=gasWithheldSwitch,proto3" json:"gas_withheld_switch"`
	// Current outbound fee multiplier, in basis points
	OutboundFeeMultiplier string `protobuf:"bytes,8,opt,name=outbound_fee_multiplier,json=outboundFeeMultiplier,proto3" json:"outbound_fee_multiplier,omitempty"`
	// the outbound transaction fee in switch, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)
	NativeOutboundFeeSwitch string `protobuf:"bytes,9,opt,name=native_outbound_fee_switch,json=nativeOutboundFeeSwitch,proto3" json:"native_outbound_fee_switch"`
	// the native transaction fee in switch, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)
	NativeTxFeeSwitch string `protobuf:"bytes,10,opt,name=native_tx_fee_switch,json=nativeTxFeeSwitch,proto3" json:"native_tx_fee_switch"`
	// the switchlyname register fee in switch, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)
	SwitchlynameRegisterFeeSwitch string `protobuf:"bytes,11,opt,name=switchlyname_register_fee_switch,json=switchlynameRegisterFeeSwitch,proto3" json:"switchlyname_register_fee_switch"`
	// the switchlyname fee per block in switch, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)
	SwitchlynameFeePerBlockSwitch string `protobuf:"bytes,12,opt,name=switchlyname_fee_per_block_switch,json=switchlynameFeePerBlockSwitch,proto3" json:"switchlyname_fee_per_block_switch"`
	// the switch price in switchly
	SwitchPriceInSwitchly string `protobuf:"bytes,13,opt,name=switch_price_in_switchly,json=switchPriceInSwitchly,proto3" json:"switch_price_in_switchly"`
	// the switchly price in switch
	SwitchlyPriceInSwitch string `protobuf:"bytes,14,opt,name=switchly_price_in_switch,json=switchlyPriceInSwitch,proto3" json:"switchly_price_in_switch"`
	// indicator if all anchor chains are halted
	SwitchlyPriceHalted bool `protobuf:"varint,17,opt,name=switchly_price_halted,json=switchlyPriceHalted,proto3" json:"switchly_price_halted"`
}

func (m *QueryNetworkResponse) Reset()         { *m = QueryNetworkResponse{} }
func (m *QueryNetworkResponse) String() string { return proto.CompactTextString(m) }
func (*QueryNetworkResponse) ProtoMessage()    {}
func (*QueryNetworkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9f8f442a8cc0ad, []int{1}
}
func (m *QueryNetworkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNetworkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNetworkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNetworkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNetworkResponse.Merge(m, src)
}
func (m *QueryNetworkResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryNetworkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNetworkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNetworkResponse proto.InternalMessageInfo

func (m *QueryNetworkResponse) GetBondRewardSwitch() string {
	if m != nil {
		return m.BondRewardSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetTotalBondUnits() string {
	if m != nil {
		return m.TotalBondUnits
	}
	return ""
}

func (m *QueryNetworkResponse) GetAvailablePoolsSwitch() string {
	if m != nil {
		return m.AvailablePoolsSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetVaultsLiquiditySwitch() string {
	if m != nil {
		return m.VaultsLiquiditySwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetEffectiveSecurityBond() string {
	if m != nil {
		return m.EffectiveSecurityBond
	}
	return ""
}

func (m *QueryNetworkResponse) GetTotalReserve() string {
	if m != nil {
		return m.TotalReserve
	}
	return ""
}

func (m *QueryNetworkResponse) GetVaultsMigrating() bool {
	if m != nil {
		return m.VaultsMigrating
	}
	return false
}

func (m *QueryNetworkResponse) GetGasSpentSwitch() string {
	if m != nil {
		return m.GasSpentSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetGasWithheldSwitch() string {
	if m != nil {
		return m.GasWithheldSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetOutboundFeeMultiplier() string {
	if m != nil {
		return m.OutboundFeeMultiplier
	}
	return ""
}

func (m *QueryNetworkResponse) GetNativeOutboundFeeSwitch() string {
	if m != nil {
		return m.NativeOutboundFeeSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetNativeTxFeeSwitch() string {
	if m != nil {
		return m.NativeTxFeeSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetSwitchlynameRegisterFeeSwitch() string {
	if m != nil {
		return m.SwitchlynameRegisterFeeSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetSwitchlynameFeePerBlockSwitch() string {
	if m != nil {
		return m.SwitchlynameFeePerBlockSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetSwitchPriceInSwitchly() string {
	if m != nil {
		return m.SwitchPriceInSwitchly
	}
	return ""
}

func (m *QueryNetworkResponse) GetSwitchlyPriceInSwitch() string {
	if m != nil {
		return m.SwitchlyPriceInSwitch
	}
	return ""
}

func (m *QueryNetworkResponse) GetSwitchlyPriceHalted() bool {
	if m != nil {
		return m.SwitchlyPriceHalted
	}
	return false
}

func init() {
	proto.RegisterType((*QueryNetworkRequest)(nil), "types.QueryNetworkRequest")
	proto.RegisterType((*QueryNetworkResponse)(nil), "types.QueryNetworkResponse")
}

func init() { proto.RegisterFile("types/query_network.proto", fileDescriptor_eb9f8f442a8cc0ad) }

var fileDescriptor_eb9f8f442a8cc0ad = []byte{
	// 699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0x4f, 0x4f, 0x13, 0x41,
	0x18, 0xc6, 0xa9, 0x0a, 0xc2, 0xc8, 0x9f, 0x76, 0x69, 0xe9, 0x82, 0xda, 0x45, 0xa2, 0x09, 0x17,
	0xe9, 0x81, 0x84, 0x93, 0xd1, 0xa4, 0x31, 0x28, 0x89, 0x68, 0x9d, 0x8a, 0x26, 0x7a, 0x98, 0x6c,
	0xdb, 0x97, 0xed, 0x84, 0xe9, 0xce, 0x32, 0x33, 0xdb, 0xd2, 0x6f, 0xe1, 0xc7, 0xf2, 0xc8, 0x4d,
	0x4f, 0x1b, 0x03, 0xb7, 0xfd, 0x14, 0x66, 0x66, 0x77, 0x5b, 0x5a, 0x5a, 0xb9, 0xed, 0x3c, 0xcf,
	0xf3, 0xfe, 0xde, 0xb7, 0xef, 0x6e, 0x07, 0x6d, 0xaa, 0x41, 0x00, 0xb2, 0x7a, 0x1e, 0x82, 0x18,
	0x10, 0x1f, 0x54, 0x9f, 0x8b, 0xb3, 0xbd, 0x40, 0x70, 0xc5, 0xad, 0x79, 0x63, 0x6d, 0x15, 0x3d,
	0xee, 0x71, 0xa3, 0x54, 0xf5, 0x53, 0x62, 0xee, 0xbc, 0x44, 0xeb, 0x9f, 0x75, 0xcd, 0xc7, 0xa4,
	0x04, 0xc3, 0x79, 0x08, 0x52, 0x59, 0x1b, 0x68, 0xa1, 0x03, 0xd4, 0xeb, 0x28, 0x3b, 0xb7, 0x9d,
	0xdb, 0x5d, 0xc2, 0xe9, 0x69, 0xe7, 0x37, 0x42, 0xc5, 0xf1, 0xbc, 0x0c, 0xb8, 0x2f, 0xc1, 0x7a,
	0x8b, 0xac, 0x26, 0xf7, 0xdb, 0x44, 0x40, 0xdf, 0x15, 0x6d, 0x22, 0xfb, 0x54, 0xb5, 0x3a, 0x49,
	0x71, 0x6d, 0x23, 0x8e, 0x9c, 0x29, 0x2e, 0xce, 0x6b, 0x0d, 0x1b, 0xa9, 0x61, 0x14, 0xeb, 0x35,
	0xca, 0x2b, 0xae, 0x5c, 0x46, 0x4c, 0x3a, 0xf4, 0xa9, 0x92, 0xf6, 0x3d, 0xc3, 0x28, 0xc6, 0x91,
	0x73, 0xcb, 0xc3, 0xab, 0x46, 0xa9, 0x71, 0xbf, 0x7d, 0xa2, 0xcf, 0x56, 0x1d, 0x6d, 0xb8, 0x3d,
	0x97, 0x32, 0xb7, 0xc9, 0x80, 0x04, 0x9c, 0x33, 0x99, 0x4d, 0xb2, 0x66, 0x28, 0x5b, 0x71, 0xe4,
	0xcc, 0x48, 0xe0, 0xe2, 0x50, 0xaf, 0x6b, 0x39, 0x9d, 0xa8, 0x81, 0xca, 0x3d, 0x37, 0x64, 0x4a,
	0x12, 0x46, 0xcf, 0x43, 0xda, 0xa6, 0x6a, 0x90, 0x21, 0xf3, 0x06, 0xf9, 0x38, 0x8e, 0x9c, 0x59,
	0x11, 0x5c, 0x4a, 0x8c, 0x0f, 0x99, 0x3e, 0x82, 0xc2, 0xe9, 0x29, 0xb4, 0x14, 0xed, 0x01, 0x91,
	0xd0, 0x0a, 0x85, 0xae, 0xd1, 0xbf, 0xcb, 0xbe, 0x3f, 0x82, 0xce, 0x88, 0xe0, 0xd2, 0xd0, 0x68,
	0xa4, 0xba, 0x5e, 0x80, 0x75, 0x80, 0x56, 0x92, 0xfd, 0x08, 0x90, 0x20, 0x7a, 0x60, 0x3f, 0x30,
	0xa8, 0x42, 0x1c, 0x39, 0xe3, 0x06, 0x5e, 0x36, 0x47, 0x9c, 0x9c, 0xac, 0x37, 0x28, 0x9f, 0x8e,
	0xdf, 0xa5, 0x9e, 0x70, 0x15, 0xf5, 0x3d, 0x7b, 0x7e, 0x3b, 0xb7, 0xbb, 0x98, 0xec, 0x7c, 0xd2,
	0xc3, 0x6b, 0x89, 0x72, 0x9c, 0x09, 0xfa, 0xa5, 0x79, 0xae, 0x24, 0x32, 0x00, 0x5f, 0x65, 0xbb,
	0x59, 0x18, 0xbd, 0xb4, 0x49, 0x0f, 0xaf, 0x7a, 0xae, 0x6c, 0x68, 0x21, 0xdd, 0xc6, 0x3b, 0xb4,
	0xae, 0x33, 0x7d, 0xaa, 0x3a, 0x1d, 0x60, 0xc3, 0x6f, 0xe7, 0xa1, 0x41, 0x94, 0xe3, 0xc8, 0x99,
	0x66, 0xe3, 0x82, 0xe7, 0xca, 0x6f, 0xa9, 0x96, 0x82, 0x0e, 0x50, 0x99, 0x87, 0xaa, 0xc9, 0x43,
	0xbf, 0x4d, 0x4e, 0x01, 0x48, 0x37, 0x64, 0x8a, 0x06, 0x8c, 0x82, 0xb0, 0x17, 0xcd, 0x57, 0x5c,
	0xca, 0xec, 0x43, 0x80, 0xe3, 0xa1, 0x69, 0xfd, 0x40, 0x5b, 0xbe, 0x6b, 0x16, 0x3d, 0x56, 0x9e,
	0xce, 0xb1, 0x64, 0xe6, 0xa8, 0xc4, 0x91, 0xf3, 0x9f, 0x14, 0x2e, 0x27, 0xde, 0xa7, 0x51, 0x83,
	0x74, 0xa8, 0x23, 0x54, 0x4c, 0xcb, 0xd4, 0xc5, 0x4d, 0x2c, 0x32, 0x58, 0x3b, 0x8e, 0x9c, 0xa9,
	0x3e, 0x2e, 0x24, 0xea, 0x97, 0x8b, 0x11, 0xaa, 0x8b, 0xb6, 0x13, 0x93, 0x0d, 0x7c, 0xb7, 0x0b,
	0x44, 0x80, 0x47, 0xa5, 0x02, 0x71, 0x13, 0xfb, 0xc8, 0x60, 0x9f, 0xc7, 0x91, 0x73, 0x67, 0x16,
	0x3f, 0xbd, 0x99, 0xc0, 0x69, 0x60, 0xd4, 0x8e, 0xa3, 0x67, 0x63, 0x08, 0x5d, 0x19, 0x80, 0x20,
	0x4d, 0xc6, 0x5b, 0x67, 0x59, 0xbf, 0x65, 0xd3, 0xef, 0x45, 0x1c, 0x39, 0x77, 0x87, 0xc7, 0x1b,
	0x1e, 0x02, 0xd4, 0x41, 0xd4, 0xb4, 0x9f, 0x36, 0x3c, 0x41, 0x76, 0x12, 0x20, 0x81, 0xa0, 0x2d,
	0x20, 0xd4, 0x27, 0x59, 0x81, 0xbd, 0x62, 0xfa, 0x3c, 0x89, 0x23, 0x67, 0x66, 0x06, 0x97, 0x92,
	0xa7, 0xba, 0x36, 0x8e, 0xfc, 0x46, 0x2a, 0x8f, 0xb0, 0x6c, 0x30, 0x59, 0x64, 0xaf, 0x4e, 0x62,
	0x6f, 0x67, 0x32, 0x2c, 0x1b, 0x8c, 0x81, 0xad, 0x63, 0x54, 0x9a, 0x28, 0xe9, 0xb8, 0x4c, 0x41,
	0xdb, 0x2e, 0x98, 0x3f, 0xcf, 0x66, 0x1c, 0x39, 0xd3, 0x03, 0x78, 0x7d, 0x0c, 0xf8, 0xde, 0x88,
	0xb5, 0xaf, 0xbf, 0xae, 0x2a, 0xb9, 0xcb, 0xab, 0x4a, 0xee, 0xef, 0x55, 0x25, 0xf7, 0xf3, 0xba,
	0x32, 0x77, 0x79, 0x5d, 0x99, 0xfb, 0x73, 0x5d, 0x99, 0xfb, 0xfe, 0xca, 0xa3, 0xaa, 0x13, 0x36,
	0xf7, 0x5a, 0xbc, 0x5b, 0xcd, 0x2a, 0xcd, 0xe5, 0xdd, 0xe2, 0x6c, 0x28, 0xf8, 0xbc, 0x0d, 0xd5,
	0xde, 0x7e, 0xf5, 0x62, 0xa8, 0x54, 0xcd, 0xb5, 0xdf, 0x5c, 0x30, 0xd1, 0xfd, 0x7f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x5e, 0x6c, 0x85, 0x16, 0x21, 0x06, 0x00, 0x00,
}

func (m *QueryNetworkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNetworkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNetworkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Height) > 0 {
		i -= len(m.Height)
		copy(dAtA[i:], m.Height)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.Height)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryNetworkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNetworkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNetworkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwitchlyPriceHalted {
		i--
		if m.SwitchlyPriceHalted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.VaultsLiquiditySwitch) > 0 {
		i -= len(m.VaultsLiquiditySwitch)
		copy(dAtA[i:], m.VaultsLiquiditySwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.VaultsLiquiditySwitch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.AvailablePoolsSwitch) > 0 {
		i -= len(m.AvailablePoolsSwitch)
		copy(dAtA[i:], m.AvailablePoolsSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.AvailablePoolsSwitch)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SwitchlyPriceInSwitch) > 0 {
		i -= len(m.SwitchlyPriceInSwitch)
		copy(dAtA[i:], m.SwitchlyPriceInSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.SwitchlyPriceInSwitch)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SwitchPriceInSwitchly) > 0 {
		i -= len(m.SwitchPriceInSwitchly)
		copy(dAtA[i:], m.SwitchPriceInSwitchly)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.SwitchPriceInSwitchly)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SwitchlynameFeePerBlockSwitch) > 0 {
		i -= len(m.SwitchlynameFeePerBlockSwitch)
		copy(dAtA[i:], m.SwitchlynameFeePerBlockSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.SwitchlynameFeePerBlockSwitch)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SwitchlynameRegisterFeeSwitch) > 0 {
		i -= len(m.SwitchlynameRegisterFeeSwitch)
		copy(dAtA[i:], m.SwitchlynameRegisterFeeSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.SwitchlynameRegisterFeeSwitch)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.NativeTxFeeSwitch) > 0 {
		i -= len(m.NativeTxFeeSwitch)
		copy(dAtA[i:], m.NativeTxFeeSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.NativeTxFeeSwitch)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.NativeOutboundFeeSwitch) > 0 {
		i -= len(m.NativeOutboundFeeSwitch)
		copy(dAtA[i:], m.NativeOutboundFeeSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.NativeOutboundFeeSwitch)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OutboundFeeMultiplier) > 0 {
		i -= len(m.OutboundFeeMultiplier)
		copy(dAtA[i:], m.OutboundFeeMultiplier)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.OutboundFeeMultiplier)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GasWithheldSwitch) > 0 {
		i -= len(m.GasWithheldSwitch)
		copy(dAtA[i:], m.GasWithheldSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.GasWithheldSwitch)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GasSpentSwitch) > 0 {
		i -= len(m.GasSpentSwitch)
		copy(dAtA[i:], m.GasSpentSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.GasSpentSwitch)))
		i--
		dAtA[i] = 0x32
	}
	if m.VaultsMigrating {
		i--
		if m.VaultsMigrating {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TotalReserve) > 0 {
		i -= len(m.TotalReserve)
		copy(dAtA[i:], m.TotalReserve)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.TotalReserve)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EffectiveSecurityBond) > 0 {
		i -= len(m.EffectiveSecurityBond)
		copy(dAtA[i:], m.EffectiveSecurityBond)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.EffectiveSecurityBond)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TotalBondUnits) > 0 {
		i -= len(m.TotalBondUnits)
		copy(dAtA[i:], m.TotalBondUnits)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.TotalBondUnits)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondRewardSwitch) > 0 {
		i -= len(m.BondRewardSwitch)
		copy(dAtA[i:], m.BondRewardSwitch)
		i = encodeVarintQueryNetwork(dAtA, i, uint64(len(m.BondRewardSwitch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQueryNetwork(dAtA []byte, offset int, v uint64) int {
	offset -= sovQueryNetwork(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryNetworkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Height)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	return n
}

func (m *QueryNetworkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondRewardSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.TotalBondUnits)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.EffectiveSecurityBond)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.TotalReserve)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	if m.VaultsMigrating {
		n += 2
	}
	l = len(m.GasSpentSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.GasWithheldSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.OutboundFeeMultiplier)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.NativeOutboundFeeSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.NativeTxFeeSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.SwitchlynameRegisterFeeSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.SwitchlynameFeePerBlockSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.SwitchPriceInSwitchly)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.SwitchlyPriceInSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.AvailablePoolsSwitch)
	if l > 0 {
		n += 1 + l + sovQueryNetwork(uint64(l))
	}
	l = len(m.VaultsLiquiditySwitch)
	if l > 0 {
		n += 2 + l + sovQueryNetwork(uint64(l))
	}
	if m.SwitchlyPriceHalted {
		n += 3
	}
	return n
}

func sovQueryNetwork(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQueryNetwork(x uint64) (n int) {
	return sovQueryNetwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryNetworkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNetworkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNetworkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Height = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNetworkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNetworkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNetworkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondRewardSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondRewardSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBondUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalBondUnits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveSecurityBond", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectiveSecurityBond = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalReserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultsMigrating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VaultsMigrating = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasSpentSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasSpentSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasWithheldSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasWithheldSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundFeeMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutboundFeeMultiplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeOutboundFeeSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeOutboundFeeSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeTxFeeSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeTxFeeSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchlynameRegisterFeeSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchlynameRegisterFeeSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchlynameFeePerBlockSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchlynameFeePerBlockSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchPriceInSwitchly", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchPriceInSwitchly = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchlyPriceInSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchlyPriceInSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailablePoolsSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailablePoolsSwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultsLiquiditySwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultsLiquiditySwitch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchlyPriceHalted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwitchlyPriceHalted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQueryNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQueryNetwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQueryNetwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQueryNetwork
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQueryNetwork
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQueryNetwork
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQueryNetwork        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQueryNetwork          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQueryNetwork = fmt.Errorf("proto: unexpected end of group")
)
