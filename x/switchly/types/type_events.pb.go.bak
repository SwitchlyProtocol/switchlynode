// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/type_events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	common "github.com/switchlyprotocol/switchlynode/v3/common"
	github_com_switchlyprotocol_switchlynode_v3_common "github.com/switchlyprotocol/switchlynode/v3/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PendingLiquidityType int32

const (
	PendingLiquidityType_add      PendingLiquidityType = 0
	PendingLiquidityType_withdraw PendingLiquidityType = 1
)

var PendingLiquidityType_name = map[int32]string{
	0: "add",
	1: "withdraw",
}

var PendingLiquidityType_value = map[string]int32{
	"add":      0,
	"withdraw": 1,
}

func (x PendingLiquidityType) String() string {
	return proto.EnumName(PendingLiquidityType_name, int32(x))
}

func (PendingLiquidityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{0}
}

type BondType int32

const (
	BondType_bond_paid     BondType = 0
	BondType_bond_returned BondType = 1
	BondType_bond_reward   BondType = 2
	BondType_bond_cost     BondType = 3
)

var BondType_name = map[int32]string{
	0: "bond_paid",
	1: "bond_returned",
	2: "bond_reward",
	3: "bond_cost",
}

var BondType_value = map[string]int32{
	"bond_paid":     0,
	"bond_returned": 1,
	"bond_reward":   2,
	"bond_cost":     3,
}

func (x BondType) String() string {
	return proto.EnumName(BondType_name, int32(x))
}

func (BondType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{1}
}

type MintBurnSupplyType int32

const (
	MintBurnSupplyType_mint MintBurnSupplyType = 0
	MintBurnSupplyType_burn MintBurnSupplyType = 1
)

var MintBurnSupplyType_name = map[int32]string{
	0: "mint",
	1: "burn",
}

var MintBurnSupplyType_value = map[string]int32{
	"mint": 0,
	"burn": 1,
}

func (x MintBurnSupplyType) String() string {
	return proto.EnumName(MintBurnSupplyType_name, int32(x))
}

func (MintBurnSupplyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{2}
}

type PoolMod struct {
	Asset     github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	SwitchAmt cosmossdk_io_math.Uint                                   `protobuf:"bytes,2,opt,name=switch_amt,json=switchAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amt"`
	SwitchAdd bool                                                     `protobuf:"varint,3,opt,name=switch_add,json=switchAdd,proto3" json:"switch_add,omitempty"`
	AssetAmt  cosmossdk_io_math.Uint                                   `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amt"`
	AssetAdd  bool                                                     `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (m *PoolMod) Reset()         { *m = PoolMod{} }
func (m *PoolMod) String() string { return proto.CompactTextString(m) }
func (*PoolMod) ProtoMessage()    {}
func (*PoolMod) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{0}
}
func (m *PoolMod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMod.Merge(m, src)
}
func (m *PoolMod) XXX_Size() int {
	return m.Size()
}
func (m *PoolMod) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMod.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMod proto.InternalMessageInfo

func (m *PoolMod) GetSwitchAdd() bool {
	if m != nil {
		return m.SwitchAdd
	}
	return false
}

func (m *PoolMod) GetAssetAdd() bool {
	if m != nil {
		return m.AssetAdd
	}
	return false
}

type EventLimitSwap struct {
	Source common.Coin                                             `protobuf:"bytes,1,opt,name=source,proto3" json:"source"`
	Target common.Coin                                             `protobuf:"bytes,2,opt,name=target,proto3" json:"target"`
	TxID   github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,3,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLimitSwap) Reset()         { *m = EventLimitSwap{} }
func (m *EventLimitSwap) String() string { return proto.CompactTextString(m) }
func (*EventLimitSwap) ProtoMessage()    {}
func (*EventLimitSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{1}
}
func (m *EventLimitSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLimitSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLimitSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLimitSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLimitSwap.Merge(m, src)
}
func (m *EventLimitSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventLimitSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLimitSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventLimitSwap proto.InternalMessageInfo

func (m *EventLimitSwap) GetSource() common.Coin {
	if m != nil {
		return m.Source
	}
	return common.Coin{}
}

func (m *EventLimitSwap) GetTarget() common.Coin {
	if m != nil {
		return m.Target
	}
	return common.Coin{}
}

func (m *EventLimitSwap) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventStreamingSwap struct {
	TxID              github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	Interval          uint64                                                  `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Quantity          uint64                                                  `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Count             uint64                                                  `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	LastHeight        int64                                                   `protobuf:"varint,5,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
	TradeTarget       cosmossdk_io_math.Uint                                  `protobuf:"bytes,6,opt,name=trade_target,json=tradeTarget,proto3,customtype=cosmossdk.io/math.Uint" json:"trade_target"`
	Deposit           common.Coin                                             `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit"`
	In                common.Coin                                             `protobuf:"bytes,8,opt,name=in,proto3" json:"in"`
	Out               common.Coin                                             `protobuf:"bytes,9,opt,name=out,proto3" json:"out"`
	FailedSwaps       []uint64                                                `protobuf:"varint,10,rep,packed,name=failed_swaps,json=failedSwaps,proto3" json:"failed_swaps,omitempty"`
	FailedSwapReasons []string                                                `protobuf:"bytes,11,rep,name=failed_swap_reasons,json=failedSwapReasons,proto3" json:"failed_swap_reasons,omitempty"`
}

func (m *EventStreamingSwap) Reset()         { *m = EventStreamingSwap{} }
func (m *EventStreamingSwap) String() string { return proto.CompactTextString(m) }
func (*EventStreamingSwap) ProtoMessage()    {}
func (*EventStreamingSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{2}
}
func (m *EventStreamingSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamingSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamingSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamingSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamingSwap.Merge(m, src)
}
func (m *EventStreamingSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamingSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamingSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamingSwap proto.InternalMessageInfo

func (m *EventStreamingSwap) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventStreamingSwap) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *EventStreamingSwap) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *EventStreamingSwap) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *EventStreamingSwap) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *EventStreamingSwap) GetDeposit() common.Coin {
	if m != nil {
		return m.Deposit
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetIn() common.Coin {
	if m != nil {
		return m.In
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetOut() common.Coin {
	if m != nil {
		return m.Out
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetFailedSwaps() []uint64 {
	if m != nil {
		return m.FailedSwaps
	}
	return nil
}

func (m *EventStreamingSwap) GetFailedSwapReasons() []string {
	if m != nil {
		return m.FailedSwapReasons
	}
	return nil
}

type EventSwap struct {
	Pool                  github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	SwapTarget            cosmossdk_io_math.Uint                                   `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3,customtype=cosmossdk.io/math.Uint" json:"swap_target"`
	SwapSlip              cosmossdk_io_math.Uint                                   `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3,customtype=cosmossdk.io/math.Uint" json:"swap_slip"`
	LiquidityFee          cosmossdk_io_math.Uint                                   `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3,customtype=cosmossdk.io/math.Uint" json:"liquidity_fee"`
	LiquidityFeeInSwitch  cosmossdk_io_math.Uint                                   `protobuf:"bytes,5,opt,name=liquidity_fee_in_switch,json=liquidityFeeInSwitch,proto3,customtype=cosmossdk.io/math.Uint" json:"liquidity_fee_in_switch"`
	InTx                  common.Tx                                                `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	OutTxs                common.Tx                                                `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs"`
	EmitAsset             common.Coin                                              `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset"`
	SynthUnits            cosmossdk_io_math.Uint                                   `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"synth_units"`
	StreamingSwapQuantity uint64                                                   `protobuf:"varint,10,opt,name=streaming_swap_quantity,json=streamingSwapQuantity,proto3" json:"streaming_swap_quantity,omitempty"`
	StreamingSwapCount    uint64                                                   `protobuf:"varint,11,opt,name=streaming_swap_count,json=streamingSwapCount,proto3" json:"streaming_swap_count,omitempty"`
	PoolSlip              cosmossdk_io_math.Uint                                   `protobuf:"bytes,12,opt,name=pool_slip,json=poolSlip,proto3,customtype=cosmossdk.io/math.Uint" json:"pool_slip"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{3}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventSwap) GetOutTxs() common.Tx {
	if m != nil {
		return m.OutTxs
	}
	return common.Tx{}
}

func (m *EventSwap) GetEmitAsset() common.Coin {
	if m != nil {
		return m.EmitAsset
	}
	return common.Coin{}
}

func (m *EventSwap) GetStreamingSwapQuantity() uint64 {
	if m != nil {
		return m.StreamingSwapQuantity
	}
	return 0
}

func (m *EventSwap) GetStreamingSwapCount() uint64 {
	if m != nil {
		return m.StreamingSwapCount
	}
	return 0
}

type EventAffiliateFee struct {
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	Memo          string                                                     `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	Switchlyname  string                                                     `protobuf:"bytes,3,opt,name=switchlyname,proto3" json:"switchlyname,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	Asset         github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,5,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	GrossAmount   cosmossdk_io_math.Uint                                     `protobuf:"bytes,6,opt,name=gross_amount,json=grossAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"gross_amount"`
	FeeBps        uint64                                                     `protobuf:"varint,7,opt,name=fee_bps,json=feeBps,proto3" json:"fee_bps,omitempty"`
	FeeAmount     cosmossdk_io_math.Uint                                     `protobuf:"bytes,8,opt,name=fee_amount,json=feeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"fee_amount"`
}

func (m *EventAffiliateFee) Reset()         { *m = EventAffiliateFee{} }
func (m *EventAffiliateFee) String() string { return proto.CompactTextString(m) }
func (*EventAffiliateFee) ProtoMessage()    {}
func (*EventAffiliateFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{4}
}
func (m *EventAffiliateFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAffiliateFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAffiliateFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAffiliateFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAffiliateFee.Merge(m, src)
}
func (m *EventAffiliateFee) XXX_Size() int {
	return m.Size()
}
func (m *EventAffiliateFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAffiliateFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventAffiliateFee proto.InternalMessageInfo

func (m *EventAffiliateFee) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventAffiliateFee) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *EventAffiliateFee) GetSwitchlyname() string {
	if m != nil {
		return m.Switchlyname
	}
	return ""
}

func (m *EventAffiliateFee) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventAffiliateFee) GetFeeBps() uint64 {
	if m != nil {
		return m.FeeBps
	}
	return 0
}

type EventAddLiquidity struct {
	Pool          github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	ProviderUnits cosmossdk_io_math.Uint                                     `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"provider_units"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	SwitchAmount  cosmossdk_io_math.Uint                                     `protobuf:"bytes,4,opt,name=switch_amount,json=switchAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amount"`
	AssetAmount   cosmossdk_io_math.Uint                                     `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amount"`
	SWITCHTxID    github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,6,opt,name=switch_tx_id,json=switchTxId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"switch_tx_id,omitempty"`
	AssetTxID     github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"asset_tx_id,omitempty"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
}

func (m *EventAddLiquidity) Reset()         { *m = EventAddLiquidity{} }
func (m *EventAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventAddLiquidity) ProtoMessage()    {}
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{5}
}
func (m *EventAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAddLiquidity.Merge(m, src)
}
func (m *EventAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventAddLiquidity proto.InternalMessageInfo

func (m *EventAddLiquidity) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventAddLiquidity) GetSWITCHTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.SWITCHTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	Pool          github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	ProviderUnits cosmossdk_io_math.Uint                                   `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"provider_units"`
	BasisPoints   int64                                                    `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry     cosmossdk_io_math.LegacyDec                              `protobuf:"bytes,4,opt,name=asymmetry,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"asymmetry"`
	InTx          common.Tx                                                `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	EmitAsset     cosmossdk_io_math.Uint                                   `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3,customtype=cosmossdk.io/math.Uint" json:"emit_asset"`
	EmitSwitch    cosmossdk_io_math.Uint                                   `protobuf:"bytes,7,opt,name=emit_switch,json=emitSwitch,proto3,customtype=cosmossdk.io/math.Uint" json:"emit_switch"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{6}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventWithdraw) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPendingLiquidity struct {
	Pool          github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	PendingType   PendingLiquidityType                                       `protobuf:"varint,2,opt,name=pending_type,json=pendingType,proto3,enum=types.PendingLiquidityType" json:"pending_type,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	SwitchAmount  cosmossdk_io_math.Uint                                     `protobuf:"bytes,4,opt,name=switch_amount,json=switchAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amount"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,5,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	AssetAmount   cosmossdk_io_math.Uint                                     `protobuf:"bytes,6,opt,name=asset_amount,json=assetAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amount"`
	SWITCHTxID    github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,7,opt,name=switch_tx_id,json=switchTxId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"switch_tx_id,omitempty"`
	AssetTxID     github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,8,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"asset_tx_id,omitempty"`
}

func (m *EventPendingLiquidity) Reset()         { *m = EventPendingLiquidity{} }
func (m *EventPendingLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventPendingLiquidity) ProtoMessage()    {}
func (*EventPendingLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{7}
}
func (m *EventPendingLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPendingLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPendingLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPendingLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPendingLiquidity.Merge(m, src)
}
func (m *EventPendingLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventPendingLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPendingLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventPendingLiquidity proto.InternalMessageInfo

func (m *EventPendingLiquidity) GetPendingType() PendingLiquidityType {
	if m != nil {
		return m.PendingType
	}
	return PendingLiquidityType_add
}

func (m *EventPendingLiquidity) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetSWITCHTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.SWITCHTxID
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

type EventDonate struct {
	Pool github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	InTx common.Tx                                                `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventDonate) Reset()         { *m = EventDonate{} }
func (m *EventDonate) String() string { return proto.CompactTextString(m) }
func (*EventDonate) ProtoMessage()    {}
func (*EventDonate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{8}
}
func (m *EventDonate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDonate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDonate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDonate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDonate.Merge(m, src)
}
func (m *EventDonate) XXX_Size() int {
	return m.Size()
}
func (m *EventDonate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDonate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDonate proto.InternalMessageInfo

func (m *EventDonate) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPool struct {
	Pool   github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	Status PoolStatus                                               `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (m *EventPool) Reset()         { *m = EventPool{} }
func (m *EventPool) String() string { return proto.CompactTextString(m) }
func (*EventPool) ProtoMessage()    {}
func (*EventPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{9}
}
func (m *EventPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPool.Merge(m, src)
}
func (m *EventPool) XXX_Size() int {
	return m.Size()
}
func (m *EventPool) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPool.DiscardUnknown(m)
}

var xxx_messageInfo_EventPool proto.InternalMessageInfo

func (m *EventPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	Asset  github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	Amount int64                                                    `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *PoolAmt) Reset()         { *m = PoolAmt{} }
func (m *PoolAmt) String() string { return proto.CompactTextString(m) }
func (*PoolAmt) ProtoMessage()    {}
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{10}
}
func (m *PoolAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAmt.Merge(m, src)
}
func (m *PoolAmt) XXX_Size() int {
	return m.Size()
}
func (m *PoolAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAmt.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAmt proto.InternalMessageInfo

func (m *PoolAmt) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type EventRewards struct {
	BondReward     cosmossdk_io_math.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=cosmossdk.io/math.Uint" json:"bond_reward"`
	PoolRewards    []PoolAmt              `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
	DevFundReward  cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=dev_fund_reward,json=devFundReward,proto3,customtype=cosmossdk.io/math.Uint" json:"dev_fund_reward"`
	IncomeBurn     cosmossdk_io_math.Uint `protobuf:"bytes,4,opt,name=income_burn,json=incomeBurn,proto3,customtype=cosmossdk.io/math.Uint" json:"income_burn"`
	TcyStakeReward cosmossdk_io_math.Uint `protobuf:"bytes,5,opt,name=tcy_stake_reward,json=tcyStakeReward,proto3,customtype=cosmossdk.io/math.Uint" json:"tcy_stake_reward"`
}

func (m *EventRewards) Reset()         { *m = EventRewards{} }
func (m *EventRewards) String() string { return proto.CompactTextString(m) }
func (*EventRewards) ProtoMessage()    {}
func (*EventRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{11}
}
func (m *EventRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewards.Merge(m, src)
}
func (m *EventRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewards proto.InternalMessageInfo

func (m *EventRewards) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRefund struct {
	Code   uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	Fee    common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
}

func (m *EventRefund) Reset()         { *m = EventRefund{} }
func (m *EventRefund) String() string { return proto.CompactTextString(m) }
func (*EventRefund) ProtoMessage()    {}
func (*EventRefund) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{12}
}
func (m *EventRefund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRefund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRefund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRefund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRefund.Merge(m, src)
}
func (m *EventRefund) XXX_Size() int {
	return m.Size()
}
func (m *EventRefund) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRefund.DiscardUnknown(m)
}

var xxx_messageInfo_EventRefund proto.InternalMessageInfo

func (m *EventRefund) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventRefund) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventRefund) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventRefund) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventBond struct {
	Amount      cosmossdk_io_math.Uint                        `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	BondType    BondType                                      `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn        common.Tx                                     `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,4,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	BondAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=bond_address,json=bondAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"bond_address,omitempty"`
}

func (m *EventBond) Reset()         { *m = EventBond{} }
func (m *EventBond) String() string { return proto.CompactTextString(m) }
func (*EventBond) ProtoMessage()    {}
func (*EventBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{13}
}
func (m *EventBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBond.Merge(m, src)
}
func (m *EventBond) XXX_Size() int {
	return m.Size()
}
func (m *EventBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventBond proto.InternalMessageInfo

func (m *EventBond) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

func (m *EventBond) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventBond) GetBondAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.BondAddress
	}
	return nil
}

type GasPool struct {
	Asset     github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	SwitchAmt cosmossdk_io_math.Uint                                   `protobuf:"bytes,2,opt,name=switch_amt,json=switchAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amt"`
	AssetAmt  cosmossdk_io_math.Uint                                   `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amt"`
	Count     int64                                                    `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GasPool) Reset()         { *m = GasPool{} }
func (m *GasPool) String() string { return proto.CompactTextString(m) }
func (*GasPool) ProtoMessage()    {}
func (*GasPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{14}
}
func (m *GasPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPool.Merge(m, src)
}
func (m *GasPool) XXX_Size() int {
	return m.Size()
}
func (m *GasPool) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPool.DiscardUnknown(m)
}

var xxx_messageInfo_GasPool proto.InternalMessageInfo

func (m *GasPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EventGas struct {
	Pools []GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
}

func (m *EventGas) Reset()         { *m = EventGas{} }
func (m *EventGas) String() string { return proto.CompactTextString(m) }
func (*EventGas) ProtoMessage()    {}
func (*EventGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{15}
}
func (m *EventGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGas.Merge(m, src)
}
func (m *EventGas) XXX_Size() int {
	return m.Size()
}
func (m *EventGas) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGas.DiscardUnknown(m)
}

var xxx_messageInfo_EventGas proto.InternalMessageInfo

func (m *EventGas) GetPools() []GasPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventReserve struct {
	ReserveContributor ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor"`
	InTx               common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventReserve) Reset()         { *m = EventReserve{} }
func (m *EventReserve) String() string { return proto.CompactTextString(m) }
func (*EventReserve) ProtoMessage()    {}
func (*EventReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{16}
}
func (m *EventReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReserve.Merge(m, src)
}
func (m *EventReserve) XXX_Size() int {
	return m.Size()
}
func (m *EventReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReserve.DiscardUnknown(m)
}

var xxx_messageInfo_EventReserve proto.InternalMessageInfo

func (m *EventReserve) GetReserveContributor() ReserveContributor {
	if m != nil {
		return m.ReserveContributor
	}
	return ReserveContributor{}
}

func (m *EventReserve) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventScheduledOutbound struct {
	OutTx TxOutItem `protobuf:"bytes,1,opt,name=out_tx,json=outTx,proto3" json:"out_tx"`
}

func (m *EventScheduledOutbound) Reset()         { *m = EventScheduledOutbound{} }
func (m *EventScheduledOutbound) String() string { return proto.CompactTextString(m) }
func (*EventScheduledOutbound) ProtoMessage()    {}
func (*EventScheduledOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{17}
}
func (m *EventScheduledOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventScheduledOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventScheduledOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventScheduledOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventScheduledOutbound.Merge(m, src)
}
func (m *EventScheduledOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventScheduledOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventScheduledOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventScheduledOutbound proto.InternalMessageInfo

func (m *EventScheduledOutbound) GetOutTx() TxOutItem {
	if m != nil {
		return m.OutTx
	}
	return TxOutItem{}
}

type EventSecurity struct {
	Msg string    `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Tx  common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventSecurity) Reset()         { *m = EventSecurity{} }
func (m *EventSecurity) String() string { return proto.CompactTextString(m) }
func (*EventSecurity) ProtoMessage()    {}
func (*EventSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{18}
}
func (m *EventSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecurity.Merge(m, src)
}
func (m *EventSecurity) XXX_Size() int {
	return m.Size()
}
func (m *EventSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecurity proto.InternalMessageInfo

func (m *EventSecurity) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EventSecurity) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventSlash struct {
	Pool        github_com_switchlyprotocol_switchlynode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"pool"`
	SlashAmount []PoolAmt                                                `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{19}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetSlashAmount() []PoolAmt {
	if m != nil {
		return m.SlashAmount
	}
	return nil
}

type EventErrata struct {
	TxID  github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	Pools PoolMods                                                `protobuf:"bytes,2,rep,name=pools,proto3,castrepeated=PoolMods" json:"pools"`
}

func (m *EventErrata) Reset()         { *m = EventErrata{} }
func (m *EventErrata) String() string { return proto.CompactTextString(m) }
func (*EventErrata) ProtoMessage()    {}
func (*EventErrata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{20}
}
func (m *EventErrata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventErrata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventErrata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventErrata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventErrata.Merge(m, src)
}
func (m *EventErrata) XXX_Size() int {
	return m.Size()
}
func (m *EventErrata) XXX_DiscardUnknown() {
	xxx_messageInfo_EventErrata.DiscardUnknown(m)
}

var xxx_messageInfo_EventErrata proto.InternalMessageInfo

func (m *EventErrata) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventErrata) GetPools() PoolMods {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventFee struct {
	TxID       github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	Fee        common.Fee                                              `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
	SynthUnits cosmossdk_io_math.Uint                                  `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"synth_units"`
}

func (m *EventFee) Reset()         { *m = EventFee{} }
func (m *EventFee) String() string { return proto.CompactTextString(m) }
func (*EventFee) ProtoMessage()    {}
func (*EventFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{21}
}
func (m *EventFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFee.Merge(m, src)
}
func (m *EventFee) XXX_Size() int {
	return m.Size()
}
func (m *EventFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventFee proto.InternalMessageInfo

func (m *EventFee) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventFee) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventOutbound struct {
	InTxID github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"in_tx_id,omitempty"`
	Tx     common.Tx                                               `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventOutbound) Reset()         { *m = EventOutbound{} }
func (m *EventOutbound) String() string { return proto.CompactTextString(m) }
func (*EventOutbound) ProtoMessage()    {}
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{22}
}
func (m *EventOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutbound.Merge(m, src)
}
func (m *EventOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutbound proto.InternalMessageInfo

func (m *EventOutbound) GetInTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.InTxID
	}
	return ""
}

func (m *EventOutbound) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventTssKeygenSuccess struct {
	PubKey  github_com_switchlyprotocol_switchlynode_v3_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.PubKey" json:"pub_key,omitempty"`
	Members []string                                                  `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Height  int64                                                     `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenSuccess) Reset()         { *m = EventTssKeygenSuccess{} }
func (m *EventTssKeygenSuccess) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenSuccess) ProtoMessage()    {}
func (*EventTssKeygenSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{23}
}
func (m *EventTssKeygenSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenSuccess.Merge(m, src)
}
func (m *EventTssKeygenSuccess) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenSuccess proto.InternalMessageInfo

func (m *EventTssKeygenSuccess) GetPubKey() github_com_switchlyprotocol_switchlynode_v3_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenSuccess) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *EventTssKeygenSuccess) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenFailure struct {
	FailReason string   `protobuf:"bytes,1,opt,name=fail_reason,json=failReason,proto3" json:"fail_reason,omitempty"`
	IsUnicast  bool     `protobuf:"varint,2,opt,name=is_unicast,json=isUnicast,proto3" json:"is_unicast,omitempty"`
	BlameNodes []string `protobuf:"bytes,3,rep,name=blame_nodes,json=blameNodes,proto3" json:"blame_nodes,omitempty"`
	Round      string   `protobuf:"bytes,4,opt,name=round,proto3" json:"round,omitempty"`
	Height     int64    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenFailure) Reset()         { *m = EventTssKeygenFailure{} }
func (m *EventTssKeygenFailure) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenFailure) ProtoMessage()    {}
func (*EventTssKeygenFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{24}
}
func (m *EventTssKeygenFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenFailure.Merge(m, src)
}
func (m *EventTssKeygenFailure) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenFailure.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenFailure proto.InternalMessageInfo

func (m *EventTssKeygenFailure) GetFailReason() string {
	if m != nil {
		return m.FailReason
	}
	return ""
}

func (m *EventTssKeygenFailure) GetIsUnicast() bool {
	if m != nil {
		return m.IsUnicast
	}
	return false
}

func (m *EventTssKeygenFailure) GetBlameNodes() []string {
	if m != nil {
		return m.BlameNodes
	}
	return nil
}

func (m *EventTssKeygenFailure) GetRound() string {
	if m != nil {
		return m.Round
	}
	return ""
}

func (m *EventTssKeygenFailure) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenMetric struct {
	PubKey           github_com_switchlyprotocol_switchlynode_v3_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.PubKey" json:"pub_key,omitempty"`
	MedianDurationMs int64                                                     `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeygenMetric) Reset()         { *m = EventTssKeygenMetric{} }
func (m *EventTssKeygenMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenMetric) ProtoMessage()    {}
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{25}
}
func (m *EventTssKeygenMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenMetric.Merge(m, src)
}
func (m *EventTssKeygenMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenMetric proto.InternalMessageInfo

func (m *EventTssKeygenMetric) GetPubKey() github_com_switchlyprotocol_switchlynode_v3_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	TxID             github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	MedianDurationMs int64                                                   `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeysignMetric) Reset()         { *m = EventTssKeysignMetric{} }
func (m *EventTssKeysignMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeysignMetric) ProtoMessage()    {}
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{26}
}
func (m *EventTssKeysignMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeysignMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeysignMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeysignMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeysignMetric.Merge(m, src)
}
func (m *EventTssKeysignMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeysignMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeysignMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeysignMetric proto.InternalMessageInfo

func (m *EventTssKeysignMetric) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	SlashPoints int64                                         `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string                                        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSlashPoint) Reset()         { *m = EventSlashPoint{} }
func (m *EventSlashPoint) String() string { return proto.CompactTextString(m) }
func (*EventSlashPoint) ProtoMessage()    {}
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{27}
}
func (m *EventSlashPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashPoint.Merge(m, src)
}
func (m *EventSlashPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashPoint proto.InternalMessageInfo

func (m *EventSlashPoint) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventSlashPoint) GetSlashPoints() int64 {
	if m != nil {
		return m.SlashPoints
	}
	return 0
}

func (m *EventSlashPoint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	PoolChange PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change"`
	Reason     string  `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventPoolBalanceChanged) Reset()         { *m = EventPoolBalanceChanged{} }
func (m *EventPoolBalanceChanged) String() string { return proto.CompactTextString(m) }
func (*EventPoolBalanceChanged) ProtoMessage()    {}
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{28}
}
func (m *EventPoolBalanceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolBalanceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolBalanceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolBalanceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolBalanceChanged.Merge(m, src)
}
func (m *EventPoolBalanceChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolBalanceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolBalanceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolBalanceChanged proto.InternalMessageInfo

func (m *EventPoolBalanceChanged) GetPoolChange() PoolMod {
	if m != nil {
		return m.PoolChange
	}
	return PoolMod{}
}

func (m *EventPoolBalanceChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventMintBurn struct {
	Supply MintBurnSupplyType     `protobuf:"varint,1,opt,name=supply,proto3,enum=types.MintBurnSupplyType" json:"supply,omitempty"`
	Denom  string                 `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Amount cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Reason string                 `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventMintBurn) Reset()         { *m = EventMintBurn{} }
func (m *EventMintBurn) String() string { return proto.CompactTextString(m) }
func (*EventMintBurn) ProtoMessage()    {}
func (*EventMintBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{29}
}
func (m *EventMintBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMintBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMintBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMintBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMintBurn.Merge(m, src)
}
func (m *EventMintBurn) XXX_Size() int {
	return m.Size()
}
func (m *EventMintBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMintBurn.DiscardUnknown(m)
}

var xxx_messageInfo_EventMintBurn proto.InternalMessageInfo

func (m *EventMintBurn) GetSupply() MintBurnSupplyType {
	if m != nil {
		return m.Supply
	}
	return MintBurnSupplyType_mint
}

func (m *EventMintBurn) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventMintBurn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventTradeAccountDeposit struct {
	Amount        cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset         github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,2,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountDeposit) Reset()         { *m = EventTradeAccountDeposit{} }
func (m *EventTradeAccountDeposit) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountDeposit) ProtoMessage()    {}
func (*EventTradeAccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{30}
}
func (m *EventTradeAccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountDeposit.Merge(m, src)
}
func (m *EventTradeAccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountDeposit proto.InternalMessageInfo

func (m *EventTradeAccountDeposit) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTradeAccountWithdraw struct {
	Amount        cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset         github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,2,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountWithdraw) Reset()         { *m = EventTradeAccountWithdraw{} }
func (m *EventTradeAccountWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountWithdraw) ProtoMessage()    {}
func (*EventTradeAccountWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{31}
}
func (m *EventTradeAccountWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountWithdraw.Merge(m, src)
}
func (m *EventTradeAccountWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountWithdraw proto.InternalMessageInfo

func (m *EventTradeAccountWithdraw) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSecuredAssetDeposit struct {
	Amount        cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset         common.Asset                                               `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSecuredAssetDeposit) Reset()         { *m = EventSecuredAssetDeposit{} }
func (m *EventSecuredAssetDeposit) String() string { return proto.CompactTextString(m) }
func (*EventSecuredAssetDeposit) ProtoMessage()    {}
func (*EventSecuredAssetDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{32}
}
func (m *EventSecuredAssetDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecuredAssetDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecuredAssetDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecuredAssetDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecuredAssetDeposit.Merge(m, src)
}
func (m *EventSecuredAssetDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventSecuredAssetDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecuredAssetDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecuredAssetDeposit proto.InternalMessageInfo

func (m *EventSecuredAssetDeposit) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSecuredAssetDeposit) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSecuredAssetDeposit) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventSecuredAssetDeposit) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSecuredAssetWithdraw struct {
	Amount        cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset         common.Asset                                               `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSecuredAssetWithdraw) Reset()         { *m = EventSecuredAssetWithdraw{} }
func (m *EventSecuredAssetWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventSecuredAssetWithdraw) ProtoMessage()    {}
func (*EventSecuredAssetWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{33}
}
func (m *EventSecuredAssetWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecuredAssetWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecuredAssetWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecuredAssetWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecuredAssetWithdraw.Merge(m, src)
}
func (m *EventSecuredAssetWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventSecuredAssetWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecuredAssetWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecuredAssetWithdraw proto.InternalMessageInfo

func (m *EventSecuredAssetWithdraw) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSecuredAssetWithdraw) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSecuredAssetWithdraw) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventSecuredAssetWithdraw) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSwitchPoolDeposit struct {
	SwitchAddress github_com_cosmos_cosmos_sdk_types.AccAddress           `protobuf:"bytes,1,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"switch_address,omitempty"`
	SwitchAmount  cosmossdk_io_math.Uint                                  `protobuf:"bytes,2,opt,name=switch_amount,json=switchAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amount"`
	Units         cosmossdk_io_math.Uint                                  `protobuf:"bytes,3,opt,name=units,proto3,customtype=cosmossdk.io/math.Uint" json:"units"`
	TxId          github_com_switchlyprotocol_switchlynode_v3_common.TxID `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSwitchPoolDeposit) Reset()         { *m = EventSwitchPoolDeposit{} }
func (m *EventSwitchPoolDeposit) String() string { return proto.CompactTextString(m) }
func (*EventSwitchPoolDeposit) ProtoMessage()    {}
func (*EventSwitchPoolDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{34}
}
func (m *EventSwitchPoolDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitchPoolDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitchPoolDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitchPoolDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitchPoolDeposit.Merge(m, src)
}
func (m *EventSwitchPoolDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitchPoolDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitchPoolDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitchPoolDeposit proto.InternalMessageInfo

func (m *EventSwitchPoolDeposit) GetSwitchAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.SwitchAddress
	}
	return nil
}

func (m *EventSwitchPoolDeposit) GetTxId() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

type EventSwitchPoolWithdraw struct {
	SwitchAddress     github_com_cosmos_cosmos_sdk_types.AccAddress              `protobuf:"bytes,1,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"switch_address,omitempty"`
	BasisPoints       int64                                                      `protobuf:"varint,2,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	SwitchAmount      cosmossdk_io_math.Uint                                     `protobuf:"bytes,3,opt,name=switch_amount,json=switchAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amount"`
	Units             cosmossdk_io_math.Uint                                     `protobuf:"bytes,4,opt,name=units,proto3,customtype=cosmossdk.io/math.Uint" json:"units"`
	TxId              github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
	AffiliateBasisPts int64                                                      `protobuf:"varint,6,opt,name=affiliate_basis_pts,json=affiliateBasisPts,proto3" json:"affiliate_basis_pts,omitempty"`
	AffiliateAmount   cosmossdk_io_math.Uint                                     `protobuf:"bytes,7,opt,name=affiliate_amount,json=affiliateAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"affiliate_amount"`
	AffiliateAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,8,opt,name=affiliate_address,json=affiliateAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"affiliate_address,omitempty"`
}

func (m *EventSwitchPoolWithdraw) Reset()         { *m = EventSwitchPoolWithdraw{} }
func (m *EventSwitchPoolWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventSwitchPoolWithdraw) ProtoMessage()    {}
func (*EventSwitchPoolWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{35}
}
func (m *EventSwitchPoolWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitchPoolWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitchPoolWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitchPoolWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitchPoolWithdraw.Merge(m, src)
}
func (m *EventSwitchPoolWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitchPoolWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitchPoolWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitchPoolWithdraw proto.InternalMessageInfo

func (m *EventSwitchPoolWithdraw) GetSwitchAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.SwitchAddress
	}
	return nil
}

func (m *EventSwitchPoolWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventSwitchPoolWithdraw) GetTxId() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *EventSwitchPoolWithdraw) GetAffiliateBasisPts() int64 {
	if m != nil {
		return m.AffiliateBasisPts
	}
	return 0
}

func (m *EventSwitchPoolWithdraw) GetAffiliateAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AffiliateAddress
	}
	return ""
}

type EventLoanOpen struct {
	CollateralDeposited    cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=collateral_deposited,json=collateralDeposited,proto3,customtype=cosmossdk.io/math.Uint" json:"collateral_deposited"`
	CollateralAsset        github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"collateral_asset"`
	CollateralizationRatio cosmossdk_io_math.Uint                                     `protobuf:"bytes,3,opt,name=collateralization_ratio,json=collateralizationRatio,proto3,customtype=cosmossdk.io/math.Uint" json:"collateralization_ratio"`
	DebtIssued             cosmossdk_io_math.Uint                                     `protobuf:"bytes,4,opt,name=debt_issued,json=debtIssued,proto3,customtype=cosmossdk.io/math.Uint" json:"debt_issued"`
	Owner                  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,5,opt,name=owner,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"owner,omitempty"`
	TargetAsset            github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,6,opt,name=target_asset,json=targetAsset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"target_asset"`
	TxID                   github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanOpen) Reset()         { *m = EventLoanOpen{} }
func (m *EventLoanOpen) String() string { return proto.CompactTextString(m) }
func (*EventLoanOpen) ProtoMessage()    {}
func (*EventLoanOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{36}
}
func (m *EventLoanOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanOpen.Merge(m, src)
}
func (m *EventLoanOpen) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanOpen.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanOpen proto.InternalMessageInfo

func (m *EventLoanOpen) GetOwner() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanOpen) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventLoanRepayment struct {
	CollateralWithdrawn cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=collateral_withdrawn,json=collateralWithdrawn,proto3,customtype=cosmossdk.io/math.Uint" json:"collateral_withdrawn"`
	CollateralAsset     github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"collateral_asset"`
	DebtRepaid          cosmossdk_io_math.Uint                                     `protobuf:"bytes,3,opt,name=debt_repaid,json=debtRepaid,proto3,customtype=cosmossdk.io/math.Uint" json:"debt_repaid"`
	Owner               github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=owner,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"owner,omitempty"`
	TxID                github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanRepayment) Reset()         { *m = EventLoanRepayment{} }
func (m *EventLoanRepayment) String() string { return proto.CompactTextString(m) }
func (*EventLoanRepayment) ProtoMessage()    {}
func (*EventLoanRepayment) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{37}
}
func (m *EventLoanRepayment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanRepayment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanRepayment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanRepayment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanRepayment.Merge(m, src)
}
func (m *EventLoanRepayment) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanRepayment) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanRepayment.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanRepayment proto.InternalMessageInfo

func (m *EventLoanRepayment) GetOwner() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanRepayment) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSWITCHName struct {
	Name            string                                                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain           github_com_switchlyprotocol_switchlynode_v3_common.Chain   `protobuf:"bytes,2,opt,name=chain,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Chain" json:"chain,omitempty"`
	Address         github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=address,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"address,omitempty"`
	RegistrationFee cosmossdk_io_math.Uint                                     `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3,customtype=cosmossdk.io/math.Uint" json:"registration_fee"`
	FundAmt         cosmossdk_io_math.Uint                                     `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"fund_amt"`
	Expire          int64                                                      `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner           github_com_cosmos_cosmos_sdk_types.AccAddress              `protobuf:"bytes,7,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
}

func (m *EventSWITCHName) Reset()         { *m = EventSWITCHName{} }
func (m *EventSWITCHName) String() string { return proto.CompactTextString(m) }
func (*EventSWITCHName) ProtoMessage()    {}
func (*EventSWITCHName) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{38}
}
func (m *EventSWITCHName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSWITCHName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSWITCHName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSWITCHName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSWITCHName.Merge(m, src)
}
func (m *EventSWITCHName) XXX_Size() int {
	return m.Size()
}
func (m *EventSWITCHName) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSWITCHName.DiscardUnknown(m)
}

var xxx_messageInfo_EventSWITCHName proto.InternalMessageInfo

func (m *EventSWITCHName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventSWITCHName) GetChain() github_com_switchlyprotocol_switchlynode_v3_common.Chain {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *EventSWITCHName) GetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventSWITCHName) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *EventSWITCHName) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

type EventSetMimir struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EventSetMimir) Reset()         { *m = EventSetMimir{} }
func (m *EventSetMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetMimir) ProtoMessage()    {}
func (*EventSetMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{39}
}
func (m *EventSetMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetMimir.Merge(m, src)
}
func (m *EventSetMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetMimir proto.InternalMessageInfo

func (m *EventSetMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type EventSetNodeMimir struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EventSetNodeMimir) Reset()         { *m = EventSetNodeMimir{} }
func (m *EventSetNodeMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetNodeMimir) ProtoMessage()    {}
func (*EventSetNodeMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{40}
}
func (m *EventSetNodeMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetNodeMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetNodeMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetNodeMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetNodeMimir.Merge(m, src)
}
func (m *EventSetNodeMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetNodeMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetNodeMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetNodeMimir proto.InternalMessageInfo

func (m *EventSetNodeMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetNodeMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *EventSetNodeMimir) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventVersion struct {
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *EventVersion) Reset()         { *m = EventVersion{} }
func (m *EventVersion) String() string { return proto.CompactTextString(m) }
func (*EventVersion) ProtoMessage()    {}
func (*EventVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{41}
}
func (m *EventVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVersion.Merge(m, src)
}
func (m *EventVersion) XXX_Size() int {
	return m.Size()
}
func (m *EventVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVersion.DiscardUnknown(m)
}

var xxx_messageInfo_EventVersion proto.InternalMessageInfo

func (m *EventVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type EventSwitch struct {
	Amount        cosmossdk_io_math.Uint                                     `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset         common.Asset                                               `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress  github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"asset_address,omitempty"`
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,4,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TxID          github_com_switchlyprotocol_switchlynode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSwitch) Reset()         { *m = EventSwitch{} }
func (m *EventSwitch) String() string { return proto.CompactTextString(m) }
func (*EventSwitch) ProtoMessage()    {}
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{42}
}
func (m *EventSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitch.Merge(m, src)
}
func (m *EventSwitch) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitch proto.InternalMessageInfo

func (m *EventSwitch) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSwitch) GetAssetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSwitch) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventSwitch) GetTxID() github_com_switchlyprotocol_switchlynode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSWCYDistribution struct {
	SwitchAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"switch_address,omitempty"`
	SwitchAmount  cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=switch_amount,json=switchAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"switch_amount"`
}

func (m *EventSWCYDistribution) Reset()         { *m = EventSWCYDistribution{} }
func (m *EventSWCYDistribution) String() string { return proto.CompactTextString(m) }
func (*EventSWCYDistribution) ProtoMessage()    {}
func (*EventSWCYDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{43}
}
func (m *EventSWCYDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSWCYDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSWCYDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSWCYDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSWCYDistribution.Merge(m, src)
}
func (m *EventSWCYDistribution) XXX_Size() int {
	return m.Size()
}
func (m *EventSWCYDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSWCYDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_EventSWCYDistribution proto.InternalMessageInfo

func (m *EventSWCYDistribution) GetSwitchAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.SwitchAddress
	}
	return nil
}

type EventSWCYClaim struct {
	SwitchAddress github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,1,opt,name=switch_address,json=switchAddress,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"switch_address,omitempty"`
	TcyAmount     cosmossdk_io_math.Uint                                     `protobuf:"bytes,2,opt,name=tcy_amount,json=tcyAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"tcy_amount"`
	L1Address     github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,3,opt,name=l1_address,json=l1Address,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"l1_address,omitempty"`
	Asset         github_com_switchlyprotocol_switchlynode_v3_common.Asset   `protobuf:"bytes,4,opt,name=asset,proto3,customtype=github.com/switchlyprotocol/switchlynode/v3/common.Asset" json:"asset"`
}

func (m *EventSWCYClaim) Reset()         { *m = EventSWCYClaim{} }
func (m *EventSWCYClaim) String() string { return proto.CompactTextString(m) }
func (*EventSWCYClaim) ProtoMessage()    {}
func (*EventSWCYClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{44}
}
func (m *EventSWCYClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSWCYClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSWCYClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSWCYClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSWCYClaim.Merge(m, src)
}
func (m *EventSWCYClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventSWCYClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSWCYClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventSWCYClaim proto.InternalMessageInfo

func (m *EventSWCYClaim) GetSwitchAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.SwitchAddress
	}
	return ""
}

func (m *EventSWCYClaim) GetL1Address() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.L1Address
	}
	return ""
}

type EventSWCYStake struct {
	Address github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"address,omitempty"`
	Amount  cosmossdk_io_math.Uint                                     `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
}

func (m *EventSWCYStake) Reset()         { *m = EventSWCYStake{} }
func (m *EventSWCYStake) String() string { return proto.CompactTextString(m) }
func (*EventSWCYStake) ProtoMessage()    {}
func (*EventSWCYStake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{45}
}
func (m *EventSWCYStake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSWCYStake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSWCYStake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSWCYStake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSWCYStake.Merge(m, src)
}
func (m *EventSWCYStake) XXX_Size() int {
	return m.Size()
}
func (m *EventSWCYStake) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSWCYStake.DiscardUnknown(m)
}

var xxx_messageInfo_EventSWCYStake proto.InternalMessageInfo

func (m *EventSWCYStake) GetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventSWCYUnstake struct {
	Address github_com_switchlyprotocol_switchlynode_v3_common.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/switchlyprotocol/switchlynode/v3/common.Address" json:"address,omitempty"`
	Amount  cosmossdk_io_math.Uint                                     `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
}

func (m *EventSWCYUnstake) Reset()         { *m = EventSWCYUnstake{} }
func (m *EventSWCYUnstake) String() string { return proto.CompactTextString(m) }
func (*EventSWCYUnstake) ProtoMessage()    {}
func (*EventSWCYUnstake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{46}
}
func (m *EventSWCYUnstake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSWCYUnstake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSWCYUnstake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSWCYUnstake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSWCYUnstake.Merge(m, src)
}
func (m *EventSWCYUnstake) XXX_Size() int {
	return m.Size()
}
func (m *EventSWCYUnstake) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSWCYUnstake.DiscardUnknown(m)
}

var xxx_messageInfo_EventSWCYUnstake proto.InternalMessageInfo

func (m *EventSWCYUnstake) GetAddress() github_com_switchlyprotocol_switchlynode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.PendingLiquidityType", PendingLiquidityType_name, PendingLiquidityType_value)
	proto.RegisterEnum("types.BondType", BondType_name, BondType_value)
	proto.RegisterEnum("types.MintBurnSupplyType", MintBurnSupplyType_name, MintBurnSupplyType_value)
	proto.RegisterType((*PoolMod)(nil), "types.PoolMod")
	proto.RegisterType((*EventLimitSwap)(nil), "types.EventLimitSwap")
	proto.RegisterType((*EventStreamingSwap)(nil), "types.EventStreamingSwap")
	proto.RegisterType((*EventSwap)(nil), "types.EventSwap")
	proto.RegisterType((*EventAffiliateFee)(nil), "types.EventAffiliateFee")
	proto.RegisterType((*EventAddLiquidity)(nil), "types.EventAddLiquidity")
	proto.RegisterType((*EventWithdraw)(nil), "types.EventWithdraw")
	proto.RegisterType((*EventPendingLiquidity)(nil), "types.EventPendingLiquidity")
	proto.RegisterType((*EventDonate)(nil), "types.EventDonate")
	proto.RegisterType((*EventPool)(nil), "types.EventPool")
	proto.RegisterType((*PoolAmt)(nil), "types.PoolAmt")
	proto.RegisterType((*EventRewards)(nil), "types.EventRewards")
	proto.RegisterType((*EventRefund)(nil), "types.EventRefund")
	proto.RegisterType((*EventBond)(nil), "types.EventBond")
	proto.RegisterType((*GasPool)(nil), "types.GasPool")
	proto.RegisterType((*EventGas)(nil), "types.EventGas")
	proto.RegisterType((*EventReserve)(nil), "types.EventReserve")
	proto.RegisterType((*EventScheduledOutbound)(nil), "types.EventScheduledOutbound")
	proto.RegisterType((*EventSecurity)(nil), "types.EventSecurity")
	proto.RegisterType((*EventSlash)(nil), "types.EventSlash")
	proto.RegisterType((*EventErrata)(nil), "types.EventErrata")
	proto.RegisterType((*EventFee)(nil), "types.EventFee")
	proto.RegisterType((*EventOutbound)(nil), "types.EventOutbound")
	proto.RegisterType((*EventTssKeygenSuccess)(nil), "types.EventTssKeygenSuccess")
	proto.RegisterType((*EventTssKeygenFailure)(nil), "types.EventTssKeygenFailure")
	proto.RegisterType((*EventTssKeygenMetric)(nil), "types.EventTssKeygenMetric")
	proto.RegisterType((*EventTssKeysignMetric)(nil), "types.EventTssKeysignMetric")
	proto.RegisterType((*EventSlashPoint)(nil), "types.EventSlashPoint")
	proto.RegisterType((*EventPoolBalanceChanged)(nil), "types.EventPoolBalanceChanged")
	proto.RegisterType((*EventMintBurn)(nil), "types.EventMintBurn")
	proto.RegisterType((*EventTradeAccountDeposit)(nil), "types.EventTradeAccountDeposit")
	proto.RegisterType((*EventTradeAccountWithdraw)(nil), "types.EventTradeAccountWithdraw")
	proto.RegisterType((*EventSecuredAssetDeposit)(nil), "types.EventSecuredAssetDeposit")
	proto.RegisterType((*EventSecuredAssetWithdraw)(nil), "types.EventSecuredAssetWithdraw")
	proto.RegisterType((*EventSwitchPoolDeposit)(nil), "types.EventSwitchPoolDeposit")
	proto.RegisterType((*EventSwitchPoolWithdraw)(nil), "types.EventSwitchPoolWithdraw")
	proto.RegisterType((*EventLoanOpen)(nil), "types.EventLoanOpen")
	proto.RegisterType((*EventLoanRepayment)(nil), "types.EventLoanRepayment")
	proto.RegisterType((*EventSWITCHName)(nil), "types.EventSWITCHName")
	proto.RegisterType((*EventSetMimir)(nil), "types.EventSetMimir")
	proto.RegisterType((*EventSetNodeMimir)(nil), "types.EventSetNodeMimir")
	proto.RegisterType((*EventVersion)(nil), "types.EventVersion")
	proto.RegisterType((*EventSwitch)(nil), "types.EventSwitch")
	proto.RegisterType((*EventSWCYDistribution)(nil), "types.EventSWCYDistribution")
	proto.RegisterType((*EventSWCYClaim)(nil), "types.EventSWCYClaim")
	proto.RegisterType((*EventSWCYStake)(nil), "types.EventSWCYStake")
	proto.RegisterType((*EventSWCYUnstake)(nil), "types.EventSWCYUnstake")
}

func init() { proto.RegisterFile("types/type_events.proto", fileDescriptor_a149b429e0dcd819) }

var fileDescriptor_a149b429e0dcd819 = []byte{
	// 2966 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0xd7, 0x72, 0x49, 0x91, 0x7c, 0xa4, 0x24, 0x7a, 0xac, 0xd8, 0x4a, 0x82, 0x48, 0xce, 0x26,
	0x5f, 0x40, 0x31, 0x62, 0xe9, 0x6b, 0xa7, 0xb5, 0x9b, 0x3a, 0x4e, 0x2a, 0x4a, 0xfe, 0x21, 0xc4,
	0x4e, 0x94, 0x95, 0x1c, 0xa7, 0x05, 0x8a, 0xc5, 0x72, 0x77, 0x44, 0x0e, 0xcc, 0xdd, 0x65, 0x76,
	0x66, 0x25, 0x32, 0xc7, 0x02, 0x45, 0x7b, 0x2a, 0x8a, 0x1e, 0x0a, 0x14, 0x0d, 0x50, 0x34, 0x0d,
	0x8a, 0x20, 0x7f, 0x40, 0x0f, 0xbd, 0x14, 0x28, 0x7a, 0x08, 0xda, 0x4b, 0x0e, 0x3d, 0x14, 0x2d,
	0xa0, 0x04, 0xca, 0xa1, 0x40, 0xfb, 0x07, 0x14, 0x30, 0x7a, 0x28, 0xe6, 0xc7, 0x2e, 0x49, 0x31,
	0x92, 0x57, 0x12, 0xa9, 0xc6, 0x85, 0x2f, 0xe2, 0xce, 0x8f, 0xf7, 0xe6, 0xcd, 0xbc, 0xcf, 0x7b,
	0xf3, 0xe6, 0xcd, 0x08, 0xce, 0xb2, 0x4e, 0x0b, 0xd3, 0x45, 0xfe, 0xd7, 0xc2, 0x5b, 0xd8, 0x67,
	0x74, 0xa1, 0x15, 0x06, 0x2c, 0x40, 0x39, 0xd1, 0xf0, 0xd4, 0x69, 0x27, 0xf0, 0xbc, 0xc0, 0x5f,
	0x94, 0x3f, 0xb2, 0xed, 0xa9, 0x27, 0x7a, 0x88, 0x5a, 0x41, 0xd0, 0x54, 0xd5, 0xcf, 0xf7, 0x54,
	0x87, 0x98, 0xe2, 0x70, 0x0b, 0x5b, 0x4e, 0xe0, 0xb3, 0x90, 0xd4, 0x22, 0x16, 0x84, 0xaa, 0x57,
	0xef, 0x88, 0xac, 0x6d, 0x05, 0x11, 0x53, 0x0d, 0xd3, 0xf5, 0xa0, 0x1e, 0x88, 0xcf, 0x45, 0xfe,
	0x25, 0x6b, 0x8d, 0x8f, 0x32, 0x90, 0x5f, 0x0b, 0x82, 0xe6, 0x9d, 0xc0, 0x45, 0x18, 0x72, 0x36,
	0xa5, 0x98, 0xcd, 0x68, 0xe7, 0xb4, 0xf9, 0xd2, 0xa5, 0x89, 0x05, 0x25, 0xd5, 0x12, 0xaf, 0xac,
	0x7e, 0xeb, 0x93, 0x9d, 0xb9, 0xb1, 0xbf, 0xee, 0xcc, 0x7d, 0xa3, 0x4e, 0x58, 0x23, 0xaa, 0xf1,
	0xc6, 0x45, 0xba, 0x4d, 0x98, 0xd3, 0x68, 0x76, 0x04, 0x2f, 0x27, 0x68, 0x26, 0x15, 0x7e, 0xe0,
	0xe2, 0xc5, 0xad, 0x97, 0x16, 0x7b, 0x39, 0x98, 0x92, 0x3b, 0xba, 0x06, 0x20, 0xbb, 0x59, 0xb6,
	0xc7, 0x66, 0x32, 0xe7, 0xb4, 0xf9, 0x62, 0x75, 0x56, 0x31, 0x3f, 0xe3, 0x04, 0xd4, 0x0b, 0x28,
	0x75, 0xef, 0x2f, 0x90, 0x60, 0xd1, 0xb3, 0x59, 0x63, 0xe1, 0x2e, 0xf1, 0x99, 0x59, 0x94, 0x14,
	0x4b, 0x1e, 0x43, 0xcf, 0x74, 0xc9, 0x5d, 0x77, 0x46, 0x3f, 0xa7, 0xcd, 0x17, 0x92, 0x66, 0xd7,
	0x45, 0x57, 0xa1, 0x28, 0x86, 0x11, 0xcc, 0xb3, 0xa9, 0x98, 0x17, 0x04, 0x01, 0xe7, 0xfd, 0x74,
	0x42, 0xec, 0xba, 0x33, 0x39, 0xc1, 0x5a, 0x35, 0xba, 0xae, 0xf1, 0x7b, 0x0d, 0x26, 0xaf, 0x73,
	0x1d, 0xde, 0x26, 0x1e, 0x61, 0xeb, 0xdb, 0x76, 0x0b, 0x9d, 0x87, 0x71, 0x1a, 0x44, 0xa1, 0x83,
	0xd5, 0x92, 0x95, 0xe3, 0x25, 0x5b, 0x0e, 0x88, 0x5f, 0xcd, 0xf2, 0x71, 0x4d, 0xd5, 0x83, 0xf7,
	0x65, 0x76, 0x58, 0xc7, 0x72, 0xca, 0xfb, 0xf4, 0x95, 0x3d, 0xd0, 0x3b, 0x90, 0x63, 0x6d, 0x8b,
	0xc8, 0xe9, 0x15, 0xab, 0xcb, 0xbb, 0x3b, 0x73, 0xd9, 0x8d, 0xf6, 0xea, 0xca, 0x83, 0x9d, 0xb9,
	0x2b, 0x47, 0x58, 0x7e, 0x4e, 0x6a, 0x66, 0x59, 0x7b, 0xd5, 0x35, 0xfe, 0xa9, 0x03, 0x12, 0x93,
	0x58, 0x67, 0x21, 0xb6, 0x3d, 0xe2, 0xd7, 0xc5, 0x44, 0x92, 0x01, 0xb5, 0x21, 0x0f, 0x88, 0x9e,
	0x82, 0x02, 0xf1, 0x19, 0x0e, 0xb7, 0xec, 0xa6, 0x98, 0x78, 0xd6, 0x4c, 0xca, 0xbc, 0xed, 0xdd,
	0xc8, 0xf6, 0x19, 0x61, 0x1d, 0x31, 0xd3, 0xac, 0x99, 0x94, 0xd1, 0x34, 0xe4, 0x9c, 0x20, 0xf2,
	0xa5, 0x0e, 0xb3, 0xa6, 0x2c, 0xa0, 0x39, 0x28, 0x35, 0x6d, 0xca, 0xac, 0x06, 0x26, 0xf5, 0x06,
	0x13, 0x2a, 0xd2, 0x4d, 0xe0, 0x55, 0xb7, 0x44, 0x0d, 0x5a, 0x82, 0x32, 0x0b, 0x6d, 0x17, 0x5b,
	0x6a, 0xad, 0xc7, 0x53, 0x21, 0xa0, 0x24, 0x68, 0x36, 0xe4, 0xe2, 0xbf, 0x08, 0x79, 0x17, 0xb7,
	0x02, 0x4a, 0xd8, 0x4c, 0x7e, 0x5f, 0x4d, 0xc5, 0x5d, 0x90, 0x01, 0x19, 0xe2, 0xcf, 0x14, 0xf6,
	0xed, 0x98, 0x21, 0x3e, 0x7a, 0x1e, 0xf4, 0x20, 0x62, 0x33, 0xc5, 0x7d, 0x3b, 0xf1, 0x66, 0xf4,
	0x2c, 0x94, 0x37, 0x6d, 0xd2, 0xc4, 0xae, 0x45, 0xb7, 0xed, 0x16, 0x9d, 0x81, 0x73, 0xfa, 0x7c,
	0xd6, 0x2c, 0xc9, 0x3a, 0xae, 0x25, 0x8a, 0x16, 0xe0, 0x74, 0x4f, 0x17, 0x2b, 0xc4, 0x36, 0x0d,
	0x7c, 0x3a, 0x53, 0x3a, 0xa7, 0xcf, 0x17, 0xcd, 0x53, 0xdd, 0x9e, 0xa6, 0x6c, 0x30, 0xfe, 0x95,
	0x83, 0xa2, 0xd4, 0x36, 0x57, 0xb2, 0x03, 0x59, 0xee, 0x4e, 0x46, 0x65, 0xde, 0x82, 0x39, 0x7a,
	0x0d, 0x4a, 0x42, 0xb6, 0x1e, 0xac, 0x3f, 0x7c, 0xfd, 0x81, 0x93, 0xa8, 0xe5, 0xbf, 0x0a, 0x45,
	0xc1, 0x80, 0x36, 0x49, 0x4b, 0xe1, 0xff, 0xa1, 0x06, 0xcc, 0x09, 0xd6, 0x9b, 0xa4, 0x85, 0x96,
	0x61, 0xa2, 0x49, 0xde, 0x8d, 0x88, 0x4b, 0x58, 0xc7, 0xda, 0xc4, 0x38, 0xa5, 0x07, 0x28, 0x27,
	0x44, 0x37, 0x30, 0x46, 0x77, 0xe1, 0x6c, 0x1f, 0x13, 0x8b, 0xf8, 0x96, 0x9c, 0xb9, 0x00, 0xdc,
	0xc3, 0xd9, 0x4d, 0xf7, 0xb2, 0x5b, 0xf5, 0xd7, 0x05, 0x2d, 0xfa, 0x3f, 0xc8, 0x11, 0xdf, 0x62,
	0x6d, 0x81, 0xc9, 0xd2, 0x25, 0x58, 0x48, 0x8c, 0x45, 0xa1, 0x20, 0x4b, 0xfc, 0x8d, 0x36, 0x7a,
	0x01, 0xf2, 0x41, 0xc4, 0x2c, 0xd6, 0xa6, 0x0a, 0x7e, 0x83, 0x1d, 0xc7, 0x83, 0x88, 0x6d, 0xb4,
	0x29, 0xba, 0x08, 0x80, 0x3d, 0xc2, 0x2c, 0xe9, 0xb5, 0xf7, 0xc7, 0x60, 0x91, 0xf7, 0x12, 0x4a,
	0x12, 0xea, 0xe9, 0xf8, 0xac, 0x61, 0x45, 0x3e, 0x61, 0x54, 0x40, 0x32, 0x8d, 0x7a, 0x38, 0xc9,
	0x5d, 0x4e, 0x81, 0x2e, 0xc3, 0x59, 0x1a, 0xbb, 0x0e, 0x89, 0xc2, 0xc4, 0x84, 0x41, 0x58, 0xea,
	0x13, 0xb4, 0xd7, 0xb3, 0xbc, 0x15, 0xdb, 0xf3, 0xff, 0xc3, 0xf4, 0x1e, 0x3a, 0x69, 0xde, 0x25,
	0x41, 0x84, 0xfa, 0x88, 0x96, 0x85, 0xad, 0x5f, 0x85, 0x22, 0x47, 0x94, 0x04, 0x42, 0x39, 0x1d,
	0x10, 0x38, 0x01, 0x07, 0x82, 0xf1, 0xa3, 0x2c, 0x9c, 0x12, 0xc8, 0x5f, 0xda, 0xdc, 0x24, 0x4d,
	0x62, 0x33, 0xcc, 0x35, 0x3b, 0x3a, 0x37, 0x87, 0x20, 0xeb, 0x61, 0x2f, 0x90, 0x78, 0x37, 0xc5,
	0x37, 0x32, 0xa0, 0x9c, 0x10, 0xda, 0x1e, 0x96, 0x60, 0x36, 0xfb, 0xea, 0x10, 0x86, 0xc9, 0xee,
	0x6e, 0x16, 0x62, 0x4a, 0x15, 0x62, 0x5f, 0x7d, 0xb0, 0x33, 0xf7, 0xcd, 0xa3, 0x98, 0xa2, 0xe4,
	0x62, 0x4e, 0x24, 0x3b, 0x22, 0x2f, 0x76, 0xb7, 0xf6, 0xdc, 0x48, 0xb7, 0xf6, 0x25, 0x28, 0xd7,
	0xc3, 0x80, 0x52, 0xcb, 0xf6, 0x84, 0x72, 0x53, 0x7a, 0x5f, 0x41, 0xb3, 0x24, 0x48, 0xd0, 0x59,
	0xc8, 0x73, 0x93, 0xab, 0xb5, 0x24, 0xfc, 0xb3, 0xe6, 0xf8, 0x26, 0xc6, 0xd5, 0x16, 0xe5, 0x61,
	0x03, 0x6f, 0x50, 0x9c, 0x0b, 0xe9, 0xc2, 0x86, 0x4d, 0x8c, 0x25, 0x5f, 0xe3, 0x1f, 0xb9, 0x18,
	0x10, 0xae, 0x7b, 0x3b, 0x36, 0xcf, 0x93, 0x71, 0x89, 0xd7, 0x61, 0xb2, 0x15, 0x06, 0x5b, 0xc4,
	0xc5, 0xa1, 0x32, 0xbb, 0x74, 0x5e, 0x71, 0x22, 0xa6, 0x92, 0x96, 0x37, 0x08, 0x15, 0x7d, 0x14,
	0x50, 0x59, 0x86, 0x89, 0x24, 0x3c, 0x4b, 0x36, 0xe0, 0x14, 0x2e, 0x34, 0x8e, 0xd0, 0x84, 0x16,
	0x97, 0xa0, 0x1c, 0x47, 0x61, 0x82, 0x47, 0x3a, 0xbf, 0x59, 0x52, 0x81, 0x98, 0x60, 0x71, 0x3f,
	0xb6, 0x1e, 0x4b, 0x9a, 0xac, 0xc4, 0xd2, 0xea, 0xee, 0xce, 0x1c, 0xac, 0xdf, 0x5b, 0xdd, 0x58,
	0xbe, 0x75, 0x5c, 0xc3, 0x55, 0x61, 0xe4, 0x06, 0x37, 0xdf, 0x06, 0xc8, 0xb1, 0xd5, 0x58, 0x79,
	0x31, 0xd6, 0xad, 0xdd, 0x9d, 0xb9, 0xa2, 0x50, 0xe4, 0x71, 0x87, 0x92, 0x51, 0xa5, 0x18, 0xc9,
	0x81, 0x89, 0x24, 0xc4, 0x14, 0x4a, 0x2c, 0x0c, 0x45, 0x89, 0xe5, 0x38, 0x4c, 0xe5, 0x25, 0xe3,
	0x13, 0x1d, 0x26, 0x04, 0xd8, 0xef, 0x11, 0xd6, 0x70, 0x43, 0x7b, 0xfb, 0x91, 0x02, 0xfa, 0xb3,
	0x50, 0xae, 0xd9, 0x94, 0x50, 0xab, 0x15, 0x10, 0x9f, 0x49, 0x98, 0xeb, 0x66, 0x49, 0xd4, 0xad,
	0x89, 0x2a, 0xb4, 0xc4, 0x03, 0xf5, 0x8e, 0xe7, 0x61, 0x16, 0x76, 0x04, 0x40, 0xcb, 0xd5, 0xe7,
	0xd4, 0x20, 0x4f, 0x0f, 0x0e, 0x72, 0x1b, 0xd7, 0x6d, 0xa7, 0xb3, 0x82, 0x1d, 0xb3, 0x4b, 0xd5,
	0xdd, 0x8e, 0x73, 0x07, 0x6e, 0xc7, 0xd7, 0xfa, 0xf6, 0xd8, 0x74, 0x0e, 0xad, 0x7f, 0xbf, 0x15,
	0xe4, 0x2a, 0x7e, 0xc8, 0xa7, 0xdb, 0x6f, 0xb1, 0x38, 0x60, 0x70, 0x0a, 0xe3, 0xef, 0x39, 0x78,
	0x42, 0xa8, 0x72, 0x0d, 0xfb, 0x2e, 0xf1, 0xeb, 0x27, 0xec, 0xbb, 0x5e, 0x85, 0x72, 0x4b, 0x0e,
	0x6c, 0xf1, 0x23, 0xa5, 0x50, 0xe8, 0xe4, 0xa5, 0xa7, 0x17, 0xc4, 0x29, 0x73, 0x61, 0xaf, 0x4c,
	0x1b, 0x9d, 0x16, 0x36, 0x4b, 0x8a, 0x80, 0x17, 0x1e, 0x29, 0xa7, 0x35, 0x60, 0x9a, 0xb9, 0xe1,
	0x9b, 0xe6, 0x80, 0x67, 0x1c, 0x3f, 0xbe, 0x67, 0xcc, 0x9f, 0xa0, 0x67, 0x2c, 0x8c, 0xcc, 0x33,
	0x1a, 0x3f, 0xd3, 0xa0, 0x24, 0x90, 0xbe, 0x12, 0xf8, 0x36, 0xc3, 0x27, 0x83, 0xef, 0xc4, 0x0b,
	0x64, 0x0e, 0xf2, 0x02, 0xc6, 0xcf, 0x35, 0x75, 0x90, 0x5a, 0xe3, 0x44, 0x27, 0x22, 0xd9, 0x0b,
	0x30, 0xbe, 0xce, 0x6c, 0x16, 0x51, 0x65, 0x73, 0xa7, 0x62, 0x9b, 0xe3, 0x21, 0xae, 0x68, 0x30,
	0x55, 0x07, 0xe3, 0x87, 0x9a, 0x4c, 0xe2, 0x2c, 0x79, 0xec, 0xa4, 0x92, 0x38, 0x67, 0x60, 0x5c,
	0x01, 0x38, 0x23, 0xbc, 0xb3, 0x2a, 0x19, 0x7f, 0xcb, 0x40, 0x59, 0x2c, 0x94, 0x89, 0xb7, 0xed,
	0xd0, 0xa5, 0xdc, 0x01, 0xd6, 0x02, 0xdf, 0xb5, 0x42, 0x51, 0x56, 0x81, 0xf7, 0x43, 0x1d, 0x20,
	0x27, 0x91, 0x1c, 0xd0, 0x15, 0x28, 0x8b, 0x63, 0x80, 0x64, 0xc0, 0x57, 0x43, 0x9f, 0x2f, 0x5d,
	0x9a, 0xec, 0x59, 0x8d, 0x25, 0x8f, 0x29, 0x65, 0x95, 0x78, 0xcf, 0x78, 0xe4, 0x1b, 0x30, 0xe5,
	0xe2, 0x2d, 0x6b, 0x33, 0xea, 0x8e, 0x9e, 0xee, 0x38, 0x39, 0xe1, 0xe2, 0xad, 0x1b, 0x51, 0x22,
	0xc0, 0x6b, 0x50, 0x22, 0xbe, 0x13, 0x78, 0xd8, 0xaa, 0x45, 0xa1, 0x9f, 0xd2, 0xb3, 0x80, 0x24,
	0xa9, 0x46, 0xa1, 0x8f, 0x6e, 0x41, 0x85, 0x39, 0x1d, 0x8b, 0x32, 0xfb, 0x3e, 0x8e, 0x25, 0x49,
	0x17, 0x10, 0x4d, 0x32, 0xa7, 0xb3, 0xce, 0xc9, 0xa4, 0x28, 0xc6, 0xf7, 0x63, 0x13, 0x31, 0x31,
	0x9f, 0x16, 0x3f, 0x75, 0x38, 0x81, 0x2b, 0xb3, 0x4f, 0x13, 0xa6, 0xf8, 0xe6, 0x9a, 0x91, 0x79,
	0x01, 0x75, 0x16, 0x51, 0xa5, 0x2e, 0xd2, 0xf5, 0x03, 0xf7, 0xbb, 0xe7, 0x40, 0x8f, 0xcf, 0xcd,
	0xa5, 0x4b, 0xa5, 0xb8, 0xd3, 0x0d, 0x8c, 0xe3, 0x54, 0xc5, 0x26, 0xc6, 0xc6, 0x1f, 0x32, 0xca,
	0x1c, 0xaa, 0x81, 0xef, 0xa2, 0xcb, 0x09, 0x16, 0xd2, 0x69, 0x57, 0xf5, 0x46, 0x2f, 0x42, 0x51,
	0x40, 0xa3, 0x67, 0x63, 0x99, 0x52, 0x6a, 0xe5, 0x7c, 0xc5, 0x66, 0x52, 0xa8, 0xa9, 0x2f, 0x2e,
	0x3f, 0x77, 0x41, 0xfe, 0xfe, 0xf2, 0xb3, 0xf6, 0xaa, 0x8f, 0x36, 0xa0, 0xcc, 0x71, 0xdb, 0x77,
	0x9c, 0x2a, 0x57, 0x2f, 0x3e, 0xd8, 0x99, 0xbb, 0xd0, 0x83, 0x79, 0x29, 0x99, 0xfa, 0xb9, 0x40,
	0xdd, 0xfb, 0x8b, 0x72, 0xdc, 0x25, 0xc7, 0x89, 0xdd, 0x76, 0x89, 0xb3, 0x89, 0xbd, 0xf6, 0x06,
	0x94, 0x85, 0xa8, 0xbd, 0x3b, 0xc3, 0xd1, 0xb8, 0x72, 0x36, 0x71, 0x98, 0xf6, 0xbd, 0x0c, 0xe4,
	0x6f, 0xda, 0x54, 0xf8, 0x94, 0x47, 0x23, 0xf9, 0xda, 0x97, 0x5d, 0xd5, 0x0f, 0x99, 0x5d, 0xed,
	0x4b, 0xe9, 0xe9, 0x2a, 0xa5, 0x67, 0x5c, 0x86, 0x82, 0x80, 0xd2, 0x4d, 0x9b, 0xa2, 0xf3, 0x90,
	0xe3, 0x16, 0x4c, 0x67, 0xb4, 0x3e, 0x23, 0x57, 0x6b, 0xa4, 0xf4, 0x2c, 0xbb, 0x18, 0x3f, 0xd0,
	0x12, 0x4f, 0x23, 0x72, 0xe1, 0x68, 0x0d, 0x4e, 0x7f, 0x49, 0x5a, 0x5c, 0xad, 0xe7, 0x93, 0x8a,
	0x95, 0xea, 0xbc, 0xdc, 0xed, 0xa0, 0xb8, 0xa2, 0x70, 0xa0, 0x25, 0xed, 0xe6, 0x70, 0x13, 0xce,
	0xc8, 0x24, 0x9b, 0xd3, 0xc0, 0x6e, 0xd4, 0xc4, 0xee, 0x9b, 0x11, 0xab, 0x05, 0xdc, 0x3e, 0x2f,
	0xc0, 0xb8, 0xcc, 0xe5, 0x28, 0x29, 0x2a, 0x4a, 0x8a, 0x8d, 0xf6, 0x9b, 0x11, 0x5b, 0x65, 0xd8,
	0x8b, 0xa7, 0x24, 0x12, 0x3a, 0xc6, 0xb2, 0x8a, 0xda, 0xd7, 0xb1, 0x13, 0x85, 0x3c, 0xc4, 0xab,
	0x80, 0xee, 0xd1, 0xba, 0x34, 0x2b, 0x93, 0x7f, 0xa2, 0x73, 0x90, 0x39, 0x40, 0x9e, 0x0c, 0x6b,
	0x1b, 0x1f, 0x6b, 0x00, 0x92, 0x4b, 0xd3, 0xa6, 0x8d, 0x93, 0xd9, 0xab, 0xae, 0x40, 0x99, 0xf2,
	0xd1, 0xac, 0x64, 0x4f, 0x38, 0xc0, 0x47, 0x8b, 0x9e, 0xea, 0x54, 0xfe, 0x8b, 0xd8, 0xa1, 0x5d,
	0x0f, 0x43, 0x9b, 0xd9, 0x23, 0x4c, 0xd0, 0x5c, 0x8e, 0xa1, 0x35, 0x28, 0xdb, 0x9d, 0xc0, 0xad,
	0x56, 0xb8, 0x6c, 0x1f, 0x7f, 0x36, 0x57, 0x50, 0x15, 0x34, 0x86, 0xd9, 0x1f, 0x35, 0x85, 0xcf,
	0xd1, 0xe6, 0x8f, 0x94, 0xdb, 0xcd, 0x1c, 0xe4, 0x76, 0xf7, 0x26, 0xef, 0xf4, 0xc3, 0x26, 0xef,
	0x8c, 0x9f, 0x68, 0x0a, 0x61, 0x09, 0x42, 0x2d, 0x28, 0x08, 0x88, 0x77, 0x27, 0x75, 0x7d, 0x77,
	0x67, 0x6e, 0x7c, 0xd5, 0x3f, 0xee, 0xb4, 0xc6, 0xb9, 0x69, 0xac, 0xba, 0x29, 0x00, 0xfb, 0x4b,
	0x4d, 0x9d, 0x70, 0x36, 0x28, 0x7d, 0x1d, 0x77, 0xea, 0xd8, 0x5f, 0x8f, 0x1c, 0x87, 0x7b, 0xdd,
	0xb7, 0x21, 0xdf, 0x8a, 0x6a, 0xd6, 0x7d, 0xdc, 0x51, 0xb2, 0x5d, 0x7b, 0xb0, 0x33, 0xf7, 0xf2,
	0x11, 0x24, 0x5a, 0x8b, 0x6a, 0xaf, 0xe3, 0x8e, 0x39, 0xde, 0x12, 0xbf, 0x68, 0x06, 0xf2, 0x1e,
	0xf6, 0x6a, 0x38, 0x94, 0x68, 0x28, 0x9a, 0x71, 0x91, 0x6f, 0x9e, 0xea, 0x6a, 0x41, 0x1e, 0x3a,
	0x55, 0xc9, 0xf8, 0xf5, 0x80, 0x8c, 0x37, 0x6c, 0xd2, 0x8c, 0x42, 0x8c, 0xe6, 0x40, 0x64, 0xe8,
	0x55, 0x2e, 0x5e, 0x99, 0x2a, 0xf0, 0x2a, 0x99, 0x84, 0x47, 0xcf, 0x00, 0x10, 0xca, 0x35, 0xe6,
	0xd8, 0x54, 0x7a, 0xdc, 0x82, 0x59, 0x24, 0xf4, 0xae, 0xac, 0xe0, 0xf4, 0xb5, 0xa6, 0xed, 0x61,
	0x8b, 0x8b, 0xcc, 0x75, 0xca, 0xe5, 0x01, 0x51, 0xf5, 0x06, 0xaf, 0xe1, 0x5e, 0x33, 0xe4, 0xaa,
	0x92, 0x81, 0x87, 0x29, 0x0b, 0x3d, 0x82, 0xe6, 0xfa, 0x04, 0x7d, 0x5f, 0x83, 0xe9, 0x7e, 0x41,
	0xef, 0x60, 0x16, 0x12, 0x67, 0x64, 0x6b, 0xf9, 0x22, 0x20, 0x0f, 0xbb, 0xc4, 0xf6, 0x2d, 0x37,
	0x0a, 0x6d, 0x46, 0x02, 0xdf, 0xf2, 0xa8, 0x0a, 0x0a, 0x2b, 0xb2, 0x65, 0x45, 0x35, 0xdc, 0xa1,
	0xdc, 0xde, 0x7b, 0xd7, 0x91, 0x92, 0x7a, 0x2c, 0xdf, 0xe8, 0x4c, 0xeb, 0x70, 0x12, 0x7e, 0xa0,
	0xc1, 0x54, 0xd7, 0x7d, 0x8a, 0x74, 0xc3, 0x40, 0x4c, 0xa1, 0x0d, 0x25, 0xa6, 0x78, 0x36, 0x76,
	0x9a, 0x2a, 0xcd, 0x21, 0x25, 0x92, 0xee, 0x51, 0xa5, 0x39, 0xba, 0xb1, 0x9c, 0xde, 0x1b, 0xcb,
	0x19, 0x0d, 0x38, 0x9b, 0x9c, 0x46, 0xaa, 0x76, 0xd3, 0xf6, 0x1d, 0xbc, 0xdc, 0xb0, 0xfd, 0x3a,
	0x76, 0xd1, 0xd7, 0x41, 0x04, 0xc1, 0x96, 0x23, 0xca, 0xca, 0xed, 0xef, 0xf5, 0x76, 0xd2, 0xf8,
	0x80, 0x77, 0x94, 0x74, 0xfb, 0x45, 0x8d, 0xc6, 0x47, 0xb1, 0xc7, 0xb8, 0x43, 0x7c, 0x26, 0xa2,
	0xd9, 0x8b, 0x30, 0x4e, 0xa3, 0x56, 0xab, 0x29, 0x71, 0x34, 0x99, 0xec, 0xac, 0x71, 0x87, 0x75,
	0xd1, 0x28, 0x82, 0x37, 0xd5, 0x91, 0x43, 0xd8, 0xc5, 0x7e, 0xe0, 0x29, 0xde, 0xb2, 0xd0, 0x13,
	0x36, 0xea, 0x87, 0x0a, 0x1b, 0xbb, 0xa2, 0x66, 0xfb, 0x44, 0xfd, 0x4c, 0x87, 0x19, 0x89, 0xad,
	0xd0, 0x76, 0xf1, 0x92, 0x23, 0xc2, 0x8b, 0x15, 0x75, 0x4d, 0x77, 0xd4, 0x18, 0x35, 0x09, 0xcb,
	0x32, 0x23, 0x0d, 0xcb, 0x06, 0x52, 0x0f, 0xfa, 0x08, 0x52, 0x0f, 0x27, 0x74, 0xd7, 0x90, 0x58,
	0x72, 0x6e, 0xd8, 0x97, 0xd7, 0x9f, 0xeb, 0xf0, 0xe4, 0x80, 0x86, 0x93, 0x14, 0xe7, 0x63, 0x15,
	0xff, 0x0f, 0xa8, 0xf8, 0x57, 0xb1, 0x11, 0x8b, 0x18, 0x18, 0xbb, 0x62, 0x09, 0x8f, 0x6b, 0xc4,
	0x2f, 0x1c, 0xa8, 0x61, 0x15, 0x82, 0x3f, 0xd6, 0x52, 0x7a, 0x2d, 0x7d, 0x18, 0x1b, 0x62, 0xaf,
	0x96, 0x8e, 0x6d, 0x88, 0x8f, 0xd5, 0x34, 0x64, 0x35, 0xfd, 0x2e, 0x13, 0x9f, 0x4c, 0x45, 0x57,
	0xbe, 0xfb, 0xc7, 0xa6, 0xf4, 0xce, 0xc0, 0xdc, 0x8e, 0x1c, 0xd4, 0x3c, 0x2c, 0x15, 0x9f, 0x39,
	0x42, 0x2a, 0xfe, 0x6b, 0x90, 0x3b, 0xcc, 0x19, 0x47, 0x76, 0x46, 0x6b, 0xf1, 0x4a, 0x4a, 0x3d,
	0x5d, 0x3d, 0xfe, 0x0a, 0xfe, 0x29, 0xab, 0x22, 0xad, 0xee, 0x0a, 0x26, 0x30, 0x1f, 0xdd, 0x12,
	0xee, 0xbd, 0x00, 0xcb, 0x0c, 0x5e, 0x80, 0x0d, 0xac, 0xb2, 0x7e, 0x9c, 0x55, 0xce, 0x1e, 0x69,
	0x95, 0x73, 0x43, 0x5a, 0x65, 0xb4, 0x00, 0xa7, 0xed, 0xf8, 0x99, 0x86, 0xa5, 0x66, 0xce, 0xa8,
	0xb8, 0x1a, 0xd1, 0xcd, 0x53, 0x49, 0x53, 0x55, 0xcc, 0x9f, 0x51, 0xb4, 0x0a, 0x95, 0x6e, 0x7f,
	0x35, 0xff, 0x74, 0x37, 0x6b, 0x53, 0x09, 0x5d, 0x72, 0x97, 0x72, 0xaa, 0x87, 0xd5, 0x50, 0xaf,
	0x64, 0xbb, 0x32, 0xc6, 0xf9, 0xbe, 0xf7, 0x73, 0x2a, 0x98, 0xbe, 0x1d, 0xd8, 0xfe, 0x9b, 0x2d,
	0xec, 0xa3, 0xb7, 0x60, 0xda, 0x09, 0x9a, 0x4d, 0x9b, 0xe1, 0xd0, 0x6e, 0x5a, 0xea, 0x4d, 0x19,
	0x4e, 0x9b, 0x26, 0x3f, 0xdd, 0xa5, 0x5d, 0x89, 0x49, 0xd1, 0x7b, 0x50, 0xe9, 0x61, 0x39, 0xd2,
	0xc8, 0x66, 0xaa, 0x3b, 0x90, 0xbc, 0xed, 0xbc, 0x07, 0x67, 0xbb, 0x55, 0xe4, 0x3d, 0x79, 0xd8,
	0x12, 0x47, 0xab, 0x94, 0xf8, 0x3c, 0x33, 0x40, 0x6e, 0xf2, 0xbf, 0xe8, 0x35, 0x28, 0xb9, 0xb8,
	0xc6, 0x2c, 0x42, 0x69, 0x84, 0xdd, 0xb4, 0x39, 0x78, 0x4e, 0xb2, 0x2a, 0x28, 0xd0, 0x06, 0xe4,
	0x82, 0x6d, 0x1f, 0x87, 0x43, 0xba, 0xd3, 0x93, 0xcc, 0x50, 0x08, 0x65, 0xf9, 0xce, 0xad, 0xe7,
	0x7a, 0x78, 0x04, 0xeb, 0x5c, 0x92, 0x83, 0xc8, 0x35, 0x4e, 0xb6, 0x8b, 0xfc, 0xb0, 0xb7, 0x8b,
	0x3f, 0xc7, 0x6f, 0x43, 0x39, 0x3c, 0x4d, 0xdc, 0xb2, 0x3b, 0x1e, 0xf6, 0xd9, 0x1e, 0x8c, 0x6e,
	0x2b, 0xf7, 0xe7, 0x1f, 0x1e, 0xa3, 0xb1, 0xe7, 0xf4, 0xff, 0xab, 0x18, 0x8d, 0xa1, 0x14, 0xe2,
	0x96, 0x4d, 0xd2, 0x5e, 0x09, 0x09, 0x28, 0x99, 0x82, 0xa2, 0x0b, 0xa5, 0xec, 0x30, 0xa1, 0x34,
	0x3a, 0xb5, 0xfe, 0x56, 0x8f, 0x33, 0x1a, 0xe2, 0x72, 0xf8, 0x0d, 0xdb, 0xc3, 0x08, 0x41, 0x56,
	0x3c, 0x49, 0x93, 0xe9, 0x2a, 0xf1, 0x8d, 0x4c, 0xc8, 0x39, 0x0d, 0x9b, 0xa8, 0x0c, 0x40, 0xf5,
	0x95, 0x07, 0x47, 0x5b, 0xf6, 0x65, 0xce, 0xc3, 0x94, 0xac, 0xd0, 0x3b, 0x90, 0x1f, 0x6e, 0x84,
	0x16, 0xb3, 0xe3, 0x7b, 0x40, 0x88, 0xeb, 0x84, 0x32, 0x95, 0xd2, 0x49, 0xff, 0xd8, 0x73, 0xaa,
	0x97, 0xee, 0x06, 0xc6, 0xe8, 0x65, 0x28, 0x88, 0x4b, 0x42, 0xdb, 0x4b, 0xfb, 0x50, 0x29, 0xcf,
	0xfb, 0x2f, 0x79, 0x22, 0x17, 0x81, 0xdb, 0x2d, 0x12, 0x62, 0xb5, 0x59, 0xa9, 0x12, 0xba, 0x19,
	0x63, 0x24, 0x7f, 0xd4, 0x90, 0x40, 0xd2, 0x1b, 0x57, 0x92, 0x2b, 0x01, 0x76, 0x87, 0x78, 0x24,
	0x44, 0x15, 0xd0, 0x93, 0x1c, 0x9e, 0xc9, 0x3f, 0xd1, 0x34, 0xe4, 0xb6, 0xec, 0x66, 0x84, 0xe3,
	0xec, 0x8a, 0x28, 0x18, 0x77, 0xd5, 0x73, 0xb7, 0x75, 0xcc, 0xde, 0x08, 0x5c, 0x7c, 0x28, 0x62,
	0x34, 0xb3, 0x47, 0x6d, 0xc9, 0xb2, 0x1b, 0xf3, 0xea, 0xd2, 0xe5, 0x6d, 0x1c, 0x52, 0x12, 0xf8,
	0xbc, 0xe7, 0x96, 0xfc, 0x54, 0x5c, 0xe3, 0xa2, 0xf1, 0x53, 0x5d, 0xa5, 0xf6, 0xd5, 0xf3, 0xd7,
	0xc7, 0xa7, 0x82, 0xaf, 0xc8, 0xa9, 0xe0, 0x37, 0x71, 0x0e, 0x76, 0xfd, 0xde, 0xf2, 0xb7, 0x57,
	0xb8, 0x25, 0x90, 0x5a, 0xc4, 0x6d, 0xe1, 0x2b, 0x7e, 0x28, 0x30, 0xfe, 0x9d, 0x51, 0xff, 0x80,
	0xc1, 0x05, 0x5f, 0x6e, 0xda, 0xc4, 0xfb, 0x12, 0x65, 0x68, 0xa3, 0x50, 0xc6, 0x35, 0x00, 0xe6,
	0x74, 0x0e, 0x27, 0x7b, 0x91, 0x39, 0x1d, 0x15, 0x64, 0x7e, 0x17, 0xa0, 0x79, 0x71, 0xc8, 0xa0,
	0x2c, 0x36, 0x2f, 0x0e, 0x3c, 0xee, 0xcd, 0x8e, 0x32, 0x81, 0x65, 0x7c, 0xa0, 0xf5, 0x2c, 0xbf,
	0x78, 0x95, 0xd0, 0xeb, 0xde, 0xb5, 0xe1, 0xba, 0xf7, 0xcb, 0x7d, 0xef, 0x4b, 0x52, 0x7b, 0x0b,
	0xe3, 0x43, 0x0d, 0x2a, 0x89, 0x90, 0x77, 0x7d, 0xfa, 0xd5, 0x14, 0xf3, 0xfc, 0x05, 0x98, 0xfe,
	0xb2, 0xb7, 0x73, 0x28, 0x0f, 0xba, 0xed, 0xba, 0x95, 0x31, 0x54, 0x86, 0x42, 0x1c, 0x69, 0x55,
	0xb4, 0xf3, 0xb7, 0xa1, 0x10, 0xbf, 0x88, 0x40, 0x13, 0xea, 0xd5, 0x04, 0x8f, 0x45, 0x2a, 0x63,
	0xe8, 0x14, 0x4c, 0xa8, 0xf7, 0x35, 0x2c, 0x0a, 0x7d, 0xec, 0x56, 0x34, 0x34, 0xd5, 0xf7, 0xe4,
	0xa6, 0x92, 0x49, 0x48, 0x9c, 0x80, 0xb2, 0x8a, 0x7e, 0x7e, 0x1e, 0xd0, 0x60, 0xb2, 0x1e, 0x15,
	0x20, 0xeb, 0x11, 0x9f, 0x55, 0xc6, 0xf8, 0x57, 0x2d, 0x0a, 0xfd, 0x8a, 0x56, 0x7d, 0xfb, 0x93,
	0xdd, 0x59, 0xed, 0xd3, 0xdd, 0x59, 0xed, 0xf3, 0xdd, 0x59, 0xed, 0xc7, 0x5f, 0xcc, 0x8e, 0x7d,
	0xfa, 0xc5, 0xec, 0xd8, 0x5f, 0xbe, 0x98, 0x1d, 0xfb, 0xce, 0x2b, 0x87, 0x59, 0xbd, 0x76, 0x52,
	0x23, 0x1d, 0x45, 0x6d, 0x5c, 0x74, 0x7d, 0xe9, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x90,
	0x48, 0xd8, 0x1f, 0x37, 0x00, 0x00,
}

func (m *PoolMod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetAdd {
		i--
		if m.AssetAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.SwitchAdd {
		i--
		if m.SwitchAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.SwitchAmt.Size()
		i -= size
		if _, err := m.SwitchAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLimitSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLimitSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLimitSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventStreamingSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamingSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStreamingSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedSwapReasons) > 0 {
		for iNdEx := len(m.FailedSwapReasons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedSwapReasons[iNdEx])
			copy(dAtA[i:], m.FailedSwapReasons[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailedSwapReasons[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FailedSwaps) > 0 {
		dAtA5 := make([]byte, len(m.FailedSwaps)*10)
		var j4 int
		for _, num := range m.FailedSwaps {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintTypeEvents(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.In.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TradeTarget.Size()
		i -= size
		if _, err := m.TradeTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LastHeight != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PoolSlip.Size()
		i -= size
		if _, err := m.PoolSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.StreamingSwapCount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapCount))
		i--
		dAtA[i] = 0x58
	}
	if m.StreamingSwapQuantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapQuantity))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.EmitAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.OutTxs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityFeeInSwitch.Size()
		i -= size
		if _, err := m.LiquidityFeeInSwitch.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LiquidityFee.Size()
		i -= size
		if _, err := m.LiquidityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwapSlip.Size()
		i -= size
		if _, err := m.SwapSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapTarget.Size()
		i -= size
		if _, err := m.SwapTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventAffiliateFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAffiliateFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAffiliateFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FeeAmount.Size()
		i -= size
		if _, err := m.FeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.FeeBps != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.FeeBps))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.GrossAmount.Size()
		i -= size
		if _, err := m.GrossAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Switchlyname) > 0 {
		i -= len(m.Switchlyname)
		copy(dAtA[i:], m.Switchlyname)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Switchlyname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SWITCHTxID) > 0 {
		i -= len(m.SWITCHTxID)
		copy(dAtA[i:], m.SWITCHTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SWITCHTxID)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.SwitchAmount.Size()
		i -= size
		if _, err := m.SwitchAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EmitSwitch.Size()
		i -= size
		if _, err := m.EmitSwitch.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.EmitAsset.Size()
		i -= size
		if _, err := m.EmitAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Asymmetry.Size()
		i -= size
		if _, err := m.Asymmetry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPendingLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPendingLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPendingLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SWITCHTxID) > 0 {
		i -= len(m.SWITCHTxID)
		copy(dAtA[i:], m.SWITCHTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SWITCHTxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.SwitchAmount.Size()
		i -= size
		if _, err := m.SwitchAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PendingType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.PendingType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDonate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDonate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDonate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TcyStakeReward.Size()
		i -= size
		if _, err := m.TcyStakeReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.IncomeBurn.Size()
		i -= size
		if _, err := m.IncomeBurn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.DevFundReward.Size()
		i -= size
		if _, err := m.DevFundReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRefund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRefund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRefund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAddress) > 0 {
		i -= len(m.BondAddress)
		copy(dAtA[i:], m.BondAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BondAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GasPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwitchAmt.Size()
		i -= size
		if _, err := m.SwitchAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReserveContributor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventScheduledOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventScheduledOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventScheduledOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashAmount) > 0 {
		for iNdEx := len(m.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventErrata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventErrata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventErrata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InTxID) > 0 {
		i -= len(m.InTxID)
		copy(dAtA[i:], m.InTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.InTxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenSuccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenSuccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Round) > 0 {
		i -= len(m.Round)
		copy(dAtA[i:], m.Round)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Round)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BlameNodes) > 0 {
		for iNdEx := len(m.BlameNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlameNodes[iNdEx])
			copy(dAtA[i:], m.BlameNodes[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BlameNodes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsUnicast {
		i--
		if m.IsUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FailReason) > 0 {
		i -= len(m.FailReason)
		copy(dAtA[i:], m.FailReason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailReason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeysignMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeysignMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeysignMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlashPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SlashPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolBalanceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolBalanceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolBalanceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PoolChange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventMintBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMintBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMintBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Supply != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecuredAssetDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecuredAssetDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecuredAssetDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecuredAssetWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecuredAssetWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecuredAssetWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSwitchPoolDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitchPoolDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitchPoolDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwitchAmount.Size()
		i -= size
		if _, err := m.SwitchAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwitchPoolWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitchPoolWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitchPoolWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AffiliateAddress) > 0 {
		i -= len(m.AffiliateAddress)
		copy(dAtA[i:], m.AffiliateAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AffiliateAddress)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.AffiliateAmount.Size()
		i -= size
		if _, err := m.AffiliateAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.AffiliateBasisPts != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.AffiliateBasisPts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwitchAmount.Size()
		i -= size
		if _, err := m.SwitchAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventLoanOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.TargetAsset.Size()
		i -= size
		if _, err := m.TargetAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.DebtIssued.Size()
		i -= size
		if _, err := m.DebtIssued.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CollateralizationRatio.Size()
		i -= size
		if _, err := m.CollateralizationRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CollateralAsset.Size()
		i -= size
		if _, err := m.CollateralAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralDeposited.Size()
		i -= size
		if _, err := m.CollateralDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLoanRepayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanRepayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanRepayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.DebtRepaid.Size()
		i -= size
		if _, err := m.DebtRepaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CollateralAsset.Size()
		i -= size
		if _, err := m.CollateralAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralWithdrawn.Size()
		i -= size
		if _, err := m.CollateralWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSWITCHName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSWITCHName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSWITCHName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Expire != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.FundAmt.Size()
		i -= size
		if _, err := m.FundAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetNodeMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetNodeMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetNodeMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSWCYDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSWCYDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSWCYDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SwitchAmount.Size()
		i -= size
		if _, err := m.SwitchAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSWCYClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSWCYClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSWCYClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.L1Address) > 0 {
		i -= len(m.L1Address)
		copy(dAtA[i:], m.L1Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.L1Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.TcyAmount.Size()
		i -= size
		if _, err := m.TcyAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SwitchAddress) > 0 {
		i -= len(m.SwitchAddress)
		copy(dAtA[i:], m.SwitchAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SwitchAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSWCYStake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSWCYStake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSWCYStake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSWCYUnstake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSWCYUnstake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSWCYUnstake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypeEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypeEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolMod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwitchAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.SwitchAdd {
		n += 2
	}
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.AssetAdd {
		n += 2
	}
	return n
}

func (m *EventLimitSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Source.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventStreamingSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovTypeEvents(uint64(m.Interval))
	}
	if m.Quantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.Quantity))
	}
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	if m.LastHeight != 0 {
		n += 1 + sovTypeEvents(uint64(m.LastHeight))
	}
	l = m.TradeTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Deposit.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.In.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Out.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.FailedSwaps) > 0 {
		l = 0
		for _, e := range m.FailedSwaps {
			l += sovTypeEvents(uint64(e))
		}
		n += 1 + sovTypeEvents(uint64(l)) + l
	}
	if len(m.FailedSwapReasons) > 0 {
		for _, s := range m.FailedSwapReasons {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFeeInSwitch.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.OutTxs.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.StreamingSwapQuantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapQuantity))
	}
	if m.StreamingSwapCount != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapCount))
	}
	l = m.PoolSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAffiliateFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Switchlyname)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.GrossAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.FeeBps != 0 {
		n += 1 + sovTypeEvents(uint64(m.FeeBps))
	}
	l = m.FeeAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.SwitchAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.SWITCHTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.Asymmetry.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitSwitch.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPendingLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.PendingType != 0 {
		n += 1 + sovTypeEvents(uint64(m.PendingType))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.SwitchAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.SWITCHTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventDonate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypeEvents(uint64(m.Status))
	}
	return n
}

func (m *PoolAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovTypeEvents(uint64(m.Amount))
	}
	return n
}

func (m *EventRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = m.DevFundReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.IncomeBurn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.TcyStakeReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventRefund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypeEvents(uint64(m.Code))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.BondAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *GasPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwitchAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	return n
}

func (m *EventGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReserveContributor.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventScheduledOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.SlashAmount) > 0 {
		for _, e := range m.SlashAmount {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventErrata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTssKeygenSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FailReason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.IsUnicast {
		n += 2
	}
	if len(m.BlameNodes) > 0 {
		for _, s := range m.BlameNodes {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = len(m.Round)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventTssKeysignMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventSlashPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SlashPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.SlashPoints))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventPoolBalanceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolChange.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventMintBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supply != 0 {
		n += 1 + sovTypeEvents(uint64(m.Supply))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSecuredAssetDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSecuredAssetWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitchPoolDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.SwitchAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitchPoolWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.SwitchAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.AffiliateBasisPts != 0 {
		n += 1 + sovTypeEvents(uint64(m.AffiliateBasisPts))
	}
	l = m.AffiliateAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AffiliateAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralDeposited.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralizationRatio.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtIssued.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.TargetAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanRepayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralWithdrawn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtRepaid.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSWITCHName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RegistrationFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.FundAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTypeEvents(uint64(m.Expire))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetNodeMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSWCYDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.SwitchAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSWCYClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SwitchAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.TcyAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.L1Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSWCYStake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSWCYUnstake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func sovTypeEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypeEvents(x uint64) (n int) {
	return sovTypeEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolMod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SwitchAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssetAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLimitSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLimitSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLimitSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamingSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamingSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamingSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TradeTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.In.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedSwaps = append(m.FailedSwaps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypeEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypeEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedSwaps) == 0 {
					m.FailedSwaps = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypeEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedSwaps = append(m.FailedSwaps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwaps", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwapReasons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedSwapReasons = append(m.FailedSwapReasons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFeeInSwitch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapQuantity", wireType)
			}
			m.StreamingSwapQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapQuantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapCount", wireType)
			}
			m.StreamingSwapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAffiliateFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAffiliateFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAffiliateFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switchlyname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Switchlyname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrossAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GrossAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBps", wireType)
			}
			m.FeeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SWITCHTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SWITCHTxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asymmetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitSwitch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitSwitch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPendingLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPendingLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPendingLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingType", wireType)
			}
			m.PendingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingType |= PendingLiquidityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SWITCHTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SWITCHTxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDonate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevFundReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DevFundReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomeBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncomeBurn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcyStakeReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TcyStakeReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRefund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAddress = append(m.BondAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.BondAddress == nil {
				m.BondAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, GasPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveContributor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventScheduledOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventScheduledOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventScheduledOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAmount = append(m.SlashAmount, PoolAmt{})
			if err := m.SlashAmount[len(m.SlashAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventErrata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, PoolMod{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InTxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenSuccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = github_com_switchlyprotocol_switchlynode_v3_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnicast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlameNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlameNodes = append(m.BlameNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = github_com_switchlyprotocol_switchlynode_v3_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeysignMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
			}
			m.SlashPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolBalanceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMintBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMintBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMintBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= MintBurnSupplyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecuredAssetDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecuredAssetDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecuredAssetDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecuredAssetWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecuredAssetWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecuredAssetWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitchPoolDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitchPoolDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitchPoolDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = append(m.SwitchAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SwitchAddress == nil {
				m.SwitchAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitchPoolWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitchPoolWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitchPoolWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = append(m.SwitchAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SwitchAddress == nil {
				m.SwitchAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateBasisPts", wireType)
			}
			m.AffiliateBasisPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateBasisPts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AffiliateAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffiliateAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralizationRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralizationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtIssued", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtIssued.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanRepayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanRepayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanRepayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtRepaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtRepaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSWITCHName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSWITCHName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSWITCHName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = github_com_switchlyprotocol_switchlynode_v3_common.Chain(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetNodeMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetNodeMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetNodeMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = github_com_switchlyprotocol_switchlynode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSWCYDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSWCYDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSWCYDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = append(m.SwitchAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SwitchAddress == nil {
				m.SwitchAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwitchAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSWCYClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSWCYClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSWCYClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchAddress = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcyAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TcyAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L1Address = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSWCYStake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSWCYStake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSWCYStake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSWCYUnstake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSWCYUnstake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSWCYUnstake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = github_com_switchlyprotocol_switchlynode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypeEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypeEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypeEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypeEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypeEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypeEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypeEvents = fmt.Errorf("proto: unexpected end of group")
)
